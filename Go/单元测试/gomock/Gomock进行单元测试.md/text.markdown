# Gomock进行单元测试

### 用法

在 mockgen 命令中,支持两种生成模式：

1. source：从源文件生成 mock 接口（通过 -source 启用）

```sh
mockgen -source=foo.go [other options]
```

2. reflect：通过使用反射程序来生成 mock 接口.它通过传递两个非标志参数来启用：导入路径和逗号分隔的接口列表

```sh
mockgen database/sql/driver Conn,Driver
```

两种方式生成的 mock 代码并没有什么区别.因此选择合适的就可以了

### 写测试用例

**1. 步骤:**

1. 想清楚整体逻辑
2. 定义想要（模拟）依赖项的 interface（接口）
3. 使用 mockgen 命令对所需 mock 的 interface 生成 mock 文件
4. 编写单元测试的逻辑,在测试中使用 mock
5. 进行单元测试的验证

**2. 目录：**

```yaml
├── mock
├── person
│   └── male.go
└── user
    ├── user.go
    └── user_test.go
```

**2. 编写：**
1. 定义 interface 

    打开 person/male.go 文件,写入以下内容：
    
```go
package person

type Male interface {
	Get(id int64) error
}
```

2. 调用方法

   打开 user/user.go 文件,写入以下内容

```go
package user

import "github.com/EDDYCJY/mockd/person"

type User struct {
	Person person.Male
}

func NewUser(p person.Male) *User {
	return &User{Person: p}
}

func (u *User) GetUserInfo(id int64) error {
	return u.Person.Get(id)
}
 ```

3. 生成 mock 文件

回到 mockd/ 的根目录下,执行以下命令

```sh
$ mockgen -source=./person/male.go -destination=./mock/male_mock.go -package=mock
```

在执行完毕后,可以发现 mock/ 目录下多出了 male_mock.go 文件,这就是 mock 文件.那么命令中的指令又分别有什么用呢？如下：

    -source：设置需要模拟（mock）的接口文件

    -destination：设置 mock 文件输出的地方,若不设置则打印到标准输出中

    -package：设置 mock 文件的包名,若不设置则为 mock_ 前缀加上文件名（如本文的包名会为 mock_person）
    
想了解更多的指令符,可参见 官方文档: https://github.com/golang/mock#running-mockgen

**输出的 mock 文件**

```go
// Code generated by MockGen. DO NOT EDIT.
// Source: ./person/male.go

// Package mock is a generated GoMock package.
package mock

import (
	gomock "github.com/golang/mock/gomock"
	reflect "reflect"
)

// MockMale is a mock of Male interface
type MockMale struct {
	ctrl     *gomock.Controller
	recorder *MockMaleMockRecorder
}

// MockMaleMockRecorder is the mock recorder for MockMale
type MockMaleMockRecorder struct {
	mock *MockMale
}

// NewMockMale creates a new mock instance
func NewMockMale(ctrl *gomock.Controller) *MockMale {
	mock := &MockMale{ctrl: ctrl}
	mock.recorder = &MockMaleMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockMale) EXPECT() *MockMaleMockRecorder {
	return m.recorder
}

// Get mocks base method
func (m *MockMale) Get(id int64) error {
	ret := m.ctrl.Call(m, "Get", id)
	ret0, _ := ret[0].(error)
	return ret0
}

// Get indicates an expected call of Get
func (mr *MockMaleMockRecorder) Get(id interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockMale)(nil).Get), id)
}
```

**4. 测试用例**

打开 user/user_test.go 文件,写入以下内容：

```go
package user

import (
	"testing"

	"github.com/EDDYCJY/mockd/mock"

	"github.com/golang/mock/gomock"
)

func TestUser_GetUserInfo(t *testing.T) {
	ctl := gomock.NewController(t)
	defer ctl.Finish()

	var id int64 = 1
	mockMale := mock.NewMockMale(ctl)
	gomock.InOrder(
		mockMale.EXPECT().Get(id).Return(nil),
	)

	user := NewUser(mockMale)
	err := user.GetUserInfo(id)
	if err != nil {
		t.Errorf("user.GetUserInfo err: %v", err)
	}
}
```

1. gomock.NewController：返回 gomock.Controller,它代表 mock 生态系统中的顶级控件.定义了 mock 对象的范围,生命周期和期待值.另外它在多个 goroutine 中是安全的
2. mock.NewMockMale：创建一个新的 mock 实例
3. gomock.InOrder：声明给定的调用应按顺序进行（是对 gomock.After 的二次封装）
4. mockMale.EXPECT().Get(id).Return(nil)：这里有三个步骤,EXPECT()返回一个允许调用者设置期望和返回值的对象.Get(id) 是设置入参并调用 mock 实例中的方法.Return(nil) 是设置先前调用的方法出参.简单来说,就是设置入参并调用,最后设置返回值

5. NewUser(mockMale)：创建 User 实例,值得注意的是,在这里注入了 mock 对象,因此实际在随后的 user.GetUserInfo(id) 调用（入参：id 为 1）中.它调用的是我们事先模拟好的 mock 方法
6. ctl.Finish()：进行 mock 用例的期望值断言,一般会使用 defer 延迟执行,以防止我们忘记这一操作

### 测试

回到 mockd/ 的根目录下,执行以下命令

```sh
$ go test ./user
```

看到这样的结果,就大功告成啦！您可以自己调整一下 Return() 的返回值,以此得到不一样的测试结果哦 

1. 测试覆盖率

```sh
go test -cover ./user
```

可通过设置 -cover 标志符来开启覆盖率的统计,展示内容为 coverage: 100.0%.

2. 可视化界面

生成测试覆盖率的 profile 文件

```sh 
go test ./... -coverprofile=cover.out
```

利用 profile 文件生成可视化界面

```sh
go tool cover -html=cover.out
```

### 常用 mock 方法

1. 调用方法
    Call.Do()：声明在匹配时要运行的操作
    
    Call.DoAndReturn()：声明在匹配调用时要运行的操作,并且模拟返回该函数的返回值
    
    Call.MaxTimes()：设置最大的调用次数为 n 次
    
    Call.MinTimes()：设置最小的调用次数为 n 次
    
    Call.AnyTimes()：允许调用次数为 0 次或更多次
    
    Call.Times()：设置调用次数为 n 次

2. 参数匹配

    gomock.Any()：匹配任意值
    
    gomock.Eq()：通过反射匹配到指定的类型值,而不需要手动设置
    gomock.Nil()：返回 nil
    
    
 ### 生成多个 mock 文件
 
 可能会想一条条命令生成 mock 文件,岂不得崩溃？

当然,官方提供了更方便的方式,我们可以利用 go:generate 来完成批量处理的功能

```sh
go generate [-run regexp] [-n] [-v] [-x] [build flags] [file.go... | packages]
```

1. 修改 interface 方法

打开 person/male.go 文件,修改为以下内容：

```go
package person

//go:generate mockgen -destination=../mock/male_mock.go -package=mock github.com/EDDYCJY/mockd/person Male

type Male interface {
	Get(id int64) error
}
```

关注到 go:generate 这条语句,可分为以下部分：

 1. 声明 //go:generate （注意不要留空格）
 2. 使用 mockgen 命令
 3. 定义 -destination
 4. 定义 -package
 5. 定义 source,此处为 person 的包路径
 6. 定义 interfaces,此处为 Male

 **注意:** 上面注释中的mockgen命令因为在调用时其当前目录是person，所以在-destination参数中我们需要指定../mocks/作为mock生成代码的输出目录。
 

有了上面的go:generate注释，我们要生成所有mock只需在项目的根目录下运行下面这条命令即可，是不是非常方便？

```sh
go generate ./...
```

**注意:** 注释中的//和go:generate之间不能有空格，这样go generate才可以把注释当做一条命令来处理。

**总结：**
在单元测试这一环,gomock 给我们提供了极大的便利.能够 mock 掉许许多多的依赖项,其中还有很多的使用方式和功能.您可以 mark 住后详细阅读下官方文档,记忆会更深刻 

