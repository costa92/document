### 字典约束

**为什么字典的键类型会受到约束 ？**

Go 语言的字典类型其实是一个哈希表 （hash table）的特定实现，在这个实现中，键和元素的最大不同在与，键的类型是受限的，而元素却可以是任意类型的

map 的 key 必须是 hash，哈希表中最重要的一个过程：映射

键和元素的这种对应关系，在数学里就是被称为：”映射“，这也是 ”map“ 这个词的本意，哈希表的映射过程就存在与对键 - 元素对的 增、删、改、查的操作之中。

```go
aMap := map[string]int{
  "one": 1,
  "two": 2,
  "three": 3,
}

k := "two"
v,ok := aMap[k]
if ok {
  fmt.Printf("The element of key %q: %d\n",k,v)
}else{
  fmt.Println("Not found !")
}
```

哈希表 会先用哈希函数（has function）把键值转换为哈希值。哈希值通常是一个无符号的整数，一个哈希表会持有一定数量的桶（bucket），也可以称为：哈希桶，哈希桶会均匀地储存其所属哈希表收纳的键 - 元素对。



**映射过程第一步就是：把键值转换为哈希值。**

在 Go 语言的字典中，每一个键值都是由它的哈希值代表的。也就是说，字典不会独立存储任何键的值，但会独立存储它们的哈希值。



什么是独立存储哈希值？

在哈希桶里均匀存储的”键-元素“对中，”键“不是指键原值，而是经哈希函数转换后得到的哈希值。



### **字典的键类型不能是哪些类型？**

Go 语言规范中找到答案，但是却没有那么简单。它的典型回答是：Go 语言字典的键类型不可以是**函数类型**、**字典类型**、**切片类型**。



Go 语言规范规定，在键类型的值必须可以施加操作符号 == 和 != 。换句话说，键类型的值必须要支持判断等操作。由于**函数类型**、**字典类型**和**切片类型**的值并不支持判等操作，所以字典的键类型不能是这些类型，

另外，如果键的类型是接口类型的，那么键值得实际类型也是不能是上述三种类型，否则程序运行过程中会引发 panic（即运行时恐慌）

```go
var badMap2 = map[interface{}]int{
  "1":   1,
  []int{2}: 2, // 这里会引发panic。
  3:    3,
}
```

badMap2 的类型是键类型为 interface{} 、值类型为 int 的字典类型。

注意：字面量在声明该字典同时对它进行了初始化，使它包含了三个键 - 元素对。

其中第二个键 - 元素对的键值是[]int{2}, 元素值是2.这样的键值也不会让Go语言编译器报错，因为从语法上说，这样做是可以的。

## map delete

Go 语言中并没有为 map 提供任何清空所有元素的函数、方法,清空 map 的唯一办法就是重新 make 一个新的 map，所有就不要担心垃圾回收的效率，Go语言中的并行垃圾回收效率比写一个清空函数要高效的多。原来的map 不会释放，仅仅是标记为不可用。不过解决的办法是手动删除  runtime.GC()







