Go 语言中的程序体包括变量、常量、函数、结构体和接口

Go 语言是静态类型的编程语言、在声明变量或常量的时候，都需要指定它们的类型，或者给予足够的信息，这样才可以让Go语言能够推导出它类型

```go
var name string // 全局变量

name := "Rebert" // 只能函数内部可用
```



![img](https://file.longqiuhong.com/markdown/b7d73fdce13a3a5f2d56d0b95f2c8cbc.png)



**Go 语言的类型推断可以带来哪些好处？**

Go 语言是静态类型的,所以一旦在初始化变量时确定了它的类型，之后就不可能在改变。这就避免了在后面维护程序的一些问题。另外，这种类型的确定是在编译期完成的，因此不会对程序的运行效率产生任何影响。

Go 语言的类型推断可以明显提升程序的灵活性，使得代码重构变得更加容易，同时又不会给代码的维护带来额外负担（实际上，它恰恰可以避免散弹式的代码修改），更不会损失程序的运行效率。



**变量的声明是什么意思**

涉及到短变量声明，通过使用它，可以对用一代码块中的变量进行重新声明。

​	代码块一般就是一个由花括号起来的区域，里面可以包含表达式和语句。Go语言本身以编写的代码共同形成了一个非常大的代码块，也叫全域代码块。

​    只要是公开的全局变量，都可以被任何代码所使用，相对小一些的代码块是代码包，一个代码包可以包含许多子代码包，所以这样的代码块也可以很大	

 每个源码文件也都是一个代码块，每个函数也是一个代码块，每个if语句、for语句、Switch语句都是一个代码块。Switch 或 select 语句中的case 子句也是都是独立的代码块。

main 函数中写一对紧挨着的花括号算不算一个代码块？ 当然也算，甚至名词，叫 ”空代码块“

其含义是对已经声明过的变量再次声明。变量声明的前提条件如下：



1、由于变量的类型在其初始化式就已经确定了，所以对它再次声明时赋予的类型必须与其原本的类型相同，否则会产生编译错误

2、变量的重声明只可能发生在某一个代码块中。如果与当前的变量重名的是外层代码块中的变量，那么就是另外一个含义了。

3、变量的重声明只有在使用短变量声明时才会发生，否则也无法通过编译。如果要次声明全新的变量，那么就应该使用包含关键字 var 的声明语句，但是这时就不能与同一个代码块中的任何变量有重名。

4、被 ”声明并赋值“的变量必须是多个，并且其中至少有一个是新的变量。这时才可以说对其中的旧变量进行了重声明。

这样来看，变量重声明其实算是一个语法糖（或者叫便利措施）。它允许我们在使用短变量声明时不用理会被赋值的多个变量中是否包含旧变量。

```go

package main

import (
	"fmt"
	"io"
	"os"
)

func main() {
	var err error
	n,err := io.WriteString(os.Stdout,"Hello , everyone!\n") // 这里对 "err" 进行了声明。
	if err != nil {
		fmt.Printf("Error:%v\n",err)
	}
	fmt.Printf("%d byte(s) were written,\n",n)
}
```

使用短变量声明对新变量n和旧变量err进行了，”声明并赋值“，这时也是对后者的重声明



基于类型推断，Go语言的类型推断只应用在了对变量或常量的初始化方面。

**如果一个变量与其外层代码块中的变量重名出现什么状态？**

```go
package main

import "fmt"

var block = "package"

func main() {
	block := "function"
	{
		block := "inner"
		fmt.Printf("The block is %s.\n",block)
	}

	fmt.Printf("The block is %s.\n",block)
}

```

代码中有四个代码块： 它们是：全域代码块、main 包代表的代码块、main 函数代表的代码块，以及在main函数中的一个用花括号包起的代码块

代码块中分别声明了一个名为block的变量，并分别把字符串值"package"、"function"和"inner"赋给了它们。此外，我在后两个代码块的最后分别尝试用fmt.Printf函数打印出“The block is %s.”。这里的“%s”只是为了占位，程序会用block变量的实际值替换掉。

执行的结果：

```go
The block is inner.
The block is function.

```

三处代码都声明了相同名称的变量。声明重名的变量是无法通过编译的，用短变量声明对已有变量进行重声明除外，但这是对于同一个代码块而言的



这个查找过程不只针对于变量，还适用于任何程序实体。如下面所示。

首先，代码引用变量的时候总会最优先查找当前代码块中的那个变量。注意，这里的“当前代码块”仅仅是引用变量的代码所在的那个代码块，并不包含任何子代码块。

其次，如果当前代码块中没有声明以此为名的变量，那么程序会沿着代码块的嵌套关系，从直接包含当前代码块的那个代码块开始，一层一层地查找。

一般情况下，程序会一直查到当前代码包代表的代码块。如果仍然找不到，那么 Go 语言的编译器就会报错了。

注意: 有一个特殊情况，如果代码导入语句写成 import . "XXX" 的形式 （注意中间的那个 ”.“）, 那么就会让这个 ”XXX“ 包中公开的程序实体，被当前源码文件中代码，视为当前代码包中的程序实体。

比如，如果有代码包导入语句 import  .  fmt , 那么我们在当前源码文件中引用fmt.Printf  函数的时候直接使用 Printf 就可以了。这个特殊情况下，程序在查找当前源码文件后会先查用这种方式导入的那些代码包。

虽然main函数首先声明的block的作用域，是整个main函数，但是在最内层的那个代码块中，它却是不可能被引用到的。反过来讲，最内层代码块中的block也不可能被该块之外的代码引用到，这也是打印内容的第二行是“The block is function.”的另一半原因。

变量重声明中的变量一定是在某一个代码块内的。注意，这里的 ”某一个代码块内“并不是包含它的任何子代码块，否则就变成了 ”多个代码块之间“。而可重名变量中涉及的变量肯定是有多个的。

变量重声明是对同一个变量的多次声明，这里的变量只有一个。而可重名变量中涉及的变量肯定是有多个的

不论对变量声明多次，其类型必须始终一致，具体遵从从它第一次被声明时给定的类型。而可重名变量之间不存在类似的限制，它们的类型可以是任意的。

如果可重名变量所在的代码块之间，存在直接或间接的嵌套关系，那么它们之间一定存在 ”屏蔽“的现象绝对不会在变量声明的场景下出现

![img](https://file.longqiuhong.com/markdown/5e68210d5639f9e42738f21bd9eb1e89.png)

具体到不同类型的可重名变量的问题上

```go

package main

import (
	"fmt"
	"io"
	"os"
)

func main() {
	var err error
	n,err := io.WriteString(os.Stdout,"Hello , everyone!\n") // 这里对 "err" 进行了声明。
	if err != nil {
		fmt.Printf("Error:%v\n",err)
	}
	fmt.Printf("%d byte(s) were written,\n",n)
}
```

有两个都叫做 container 的变量，分别位于 main 包代码块和main函数代码块。main 包代码块中的变量时切片 （slice） 类型的，另一个是字典（map）类型的。

在main函数的最后，打印出container变量的值中索引为1的那个元素。

如果container的类型不是数组、切片或字典类型，那么索引表达式就会引发编译错误。这正是利用 go 语言语法，但是我们想知道container 确切类型的时候，利用索引表达式的方式就不够。

当可重名变量的值被转成某个接口类型值，或者它们的类型本身就是接口类型的时候，严格的类型检查就很有必要了，至于怎么检查。





**类型转换规则中有哪些值得注意的地方？**

类型转换表达的基本写法语法形式 T(x)。

其中的x可以是一个变量，也可以是一个代表值得字面量（比如 1.23 和 struct{}{}),还可是一个表达式。



注意，如果是表达式，那么该表达式的结果只能是一个值，不能是多个值，在这个上下中，x可以被叫做 源值，它的类型就是源类型，而那个T代表的类型就是目标类型。

1、 **对于整数类型值、整数常量之间的类型转换，原则上只要源值在目标类型的可表示范围内就是合法的**

比如 之所以 uint8(255) 可以把无类型的常量 255 转换为 uint8 类型的值。是因为255 在 [0~255] 的范围类

注意：

固定长度的整型，包括有符号整型或无符号整型。整型范围
Int8 - [-128 : 127]
Int16 - [-32768 : 32767]
Int32 - [-2147483648 : 2147483647]
Int64 - [-9223372036854775808 : 9223372036854775807]

无符号整型范围
UInt8 - [0 : 255]
UInt16 - [0 : 65535]
UInt32 - [0 : 4294967295]
UInt64 - [0 : 18446744073709551615]

2 、**虽然直接把一个整数转换为一个 string 类型的值是可行的，但值得关注的是，被转换的整数值应该可以代表一个有效的 unicode 代码点, 否则转换的结果是"�"（仅由高亮的问号组成的字符串值）**

字符'�'的 Unicode 代码点是U+FFFD。它是 Unicode 标准中定义的 Replacement Character，专用于替换那些未知的、不被认可的以及无法展示的字符。

```go
string(-1)

// 输出的结果:�
```

由于-1肯定无法代表一个有效的 Unicode 代码点，所以得到的总会是"�"。在实际工作中，我们在排查问题时可能会遇到�，你需要知道这可能是由于什么引起的。



3、**关于 string 类型与各种切片类型之间的互转的**

一个值在从 string 类型向 [] byte 类型转换时代表着以 UTF-8 编码的字符串会被拆分成一个个Unicode字符

```go
string([]byte{'\xe4', '\xbd', '\xa0', '\xe5', '\xa5', '\xbd'}) // 你好

```

### 什么是别名类型？什么是潜在类型？



可以用关键字 type 声明自定义的各种类型的，这些类型必须是go 语言基本类型和高级类型的范畴之内，在它们当中，有一种被叫做”别名类型“的类型。

eg：

```go
type MyString = string
```

 这条声明语句表示，MyString 是 string 类型的别名类型。顾名思义 别名类型与其源类型的区别恐怕只是在名称上，它们是完全相同的

源类型与别名类型 是 一对概念，是两个对立的称呼，别名类型主要是为了代码重构而存在的，更详细的信息可参见Go语言的文档 



Go 语言内建的基本类型中就存在两个别名类型。byte是uint8的别名类型，而rune 是 int32 的别名类型

```go
type MyString2 string // 注意，这里没有等号。
```

MyString2和string就是两个不同的类型了。这里的MyString2是一个新的类型，不同于其他任何类型。

![img](https://static001.geekbang.org/resource/image/4f/f2/4f113b74b564ad3b4b4877abca7b6bf2.png)



搞清楚这三个概念以及区别：

 var myString = string (别名类型) type

 myString string (类型再定义，string是潜在类型)

对于这里的类型再定义来说，string可以被称为MyString2的潜在类型。潜在类型的含义是，某个类型在本质上是哪个类型。

潜在类型相同的不同类型的值之间是可以进行类型转换的。因此，MyString2类型的值与string类型的值可以使用类型转换表达式进行互转。



但对于集合类的类型[]MyString2与[]string来说这样做却是不合法的，因为[]MyString2与[]string的潜在类型不同，分别是[]MyString2和[]string。另外，即使两个不同类型的潜在类型相同，它们的值之间也不能进行判等或比较，它们的变量之间也不能赋值。

