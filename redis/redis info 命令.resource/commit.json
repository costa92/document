{"compress":true,"commitItems":[["fb610e1d-f8bc-48ce-9858-0151337cff55",1614151266567,"",[[1614151215565,["costalong@longqiuhongdeMacBook-Pro.local",[[1,0,"# redis info 命令\n\n\n\n"]],[0,0],[18,18]]],[1614151225205,["costalong@longqiuhongdeMacBook-Pro.local",[[1,18,"Redis Info 命令以一种易于理解和阅读的格式，返回关于 Redis 服务器的各种信息和统计数值。"]],[18,18],[70,70]]],[1614151226538,["costalong@longqiuhongdeMacBook-Pro.local",[[-1,17,"\n"]],[17,17],[16,16]]],[1614151227931,["costalong@longqiuhongdeMacBook-Pro.local",[[1,70,"\n"]],[69,69],[70,70]]],[1614151228070,["costalong@longqiuhongdeMacBook-Pro.local",[[1,71,"\n"]],[70,70],[71,71]]],[1614151236660,["costalong@longqiuhongdeMacBook-Pro.local",[[1,71,"通过给定可选的参数 section ，可以让命令只返回某一部分的信息："]],[71,71],[106,106]]],[1614151249650,["costalong@longqiuhongdeMacBook-Pro.local",[[1,107,"\n"]],[106,106],[107,107]]],[1614151249820,["costalong@longqiuhongdeMacBook-Pro.local",[[1,108,"\n"]],[107,107],[108,108]]],[1614151250098,["costalong@longqiuhongdeMacBook-Pro.local",[[1,108,"*   server : 一般 Redis 服务器信息，包含以下域：\n\n    *   redis_version : Redis 服务器版本\n    *   redis_git_sha1 : Git SHA1\n    *   redis_git_dirty : Git dirty flag\n    *   os : Redis 服务器的宿主操作系统\n    *   arch_bits : 架构（32 或 64 位）\n    *   multiplexing_api : Redis 所使用的事件处理机制\n    *   gcc_version : 编译 Redis 时所使用的 GCC 版本\n    *   process_id : 服务器进程的 PID\n    *   run_id : Redis 服务器的随机标识符（用于 Sentinel 和集群）\n    *   tcp_port : TCP/IP 监听端口\n    *   uptime_in_seconds : 自 Redis 服务器启动以来，经过的秒数\n    *   uptime_in_days : 自 Redis 服务器启动以来，经过的天数\n    *   lru_clock : 以分钟为单位进行自增的时钟，用于 LRU 管理\n*   clients : 已连接客户端信息，包含以下域：\n\n    *   connected_clients : 已连接客户端的数量（不包括通过从属服务器连接的客户端）\n    *   client_longest_output_list : 当前连接的客户端当中，最长的输出列表\n    *   client_longest_input_buf : 当前连接的客户端当中，最大输入缓存\n    *   blocked_clients : 正在等待阻塞命令（BLPOP、BRPOP、BRPOPLPUSH）的客户端的数量\n*   memory : 内存信息，包含以下域：\n\n    *   used_memory : 由 Redis 分配器分配的内存总量，以字节（byte）为单位\n    *   used_memory_human : 以人类可读的格式返回 Redis 分配的内存总量\n    *   used_memory_rss : 从操作系统的角度，返回 Redis 已分配的内存总量（俗称常驻集大小）。这个值和 top 、 ps 等命令的输出一致。\n    *   used_memory_peak : Redis 的内存消耗峰值（以字节为单位）\n    *   used_memory_peak_human : 以人类可读的格式返回 Redis 的内存消耗峰值\n    *   used_memory_lua : Lua 引擎所使用的内存大小（以字节为单位）\n    *   mem_fragmentation_ratio : used_memory_rss 和 used_memory 之间的比率\n    *   mem_allocator : 在编译时指定的， Redis 所使用的内存分配器。可以是 libc 、 jemalloc 或者 tcmalloc 。\n\n    在理想情况下， used_memory_rss 的值应该只比 used_memory 稍微高一点儿。\n\n    当 rss > used ，且两者的值相差较大时，表示存在（内部或外部的）内存碎片。\n\n    内存碎片的比率可以通过 mem_fragmentation_ratio 的值看出。\n\n    当 used > rss 时，表示 Redis 的部分内存被操作系统换出到交换空间了，在这种情况下，操作可能会产生明显的延迟。\n\n    当 Redis 释放内存时，分配器可能会，也可能不会，将内存返还给操作系统。\n\n    如果 Redis 释放了内存，却没有将内存返还给操作系统，那么 used_memory 的值可能和操作系统显示的 Redis 内存占用并不一致。\n\n    查看 used_memory_peak 的值可以验证这种情况是否发生。\n\n*   persistence : RDB 和 AOF 的相关信息\n\n*   stats : 一般统计信息\n\n*   replication : 主/从复制信息\n\n*   cpu : CPU 计算量统计信息\n\n*   commandstats : Redis 命令统计信息\n\n*   cluster : Redis 集群信息\n\n*   keyspace : 数据库相关的统计信息"]],[108,108],[2024,2024]]]],null,"costalong@longqiuhongdeMacBook-Pro.local"]]}