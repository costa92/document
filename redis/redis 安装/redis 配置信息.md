#  redis的配置信息

通过 vim /etc/redis/redis.conf 命令打开此文件。下面我们将详细介绍此配置文件。

```
＃Redis配置文件示例。
＃
＃注意，为了读取配置文件，Redis必须是
＃以文件路径作为第一个参数开头：
＃
＃./redis-server /path/to/redis.conf

＃关于单位的注释：当需要内存大小时，可以指定
＃以通常的1k 5GB 4M格式，依此类推：
＃
＃1k => 1000字节
＃1kb => 1024字节
＃1m => 1000000字节
＃1mb => 1024 * 1024字节
＃1g => 1000000000字节
＃1gb => 1024 * 1024 * 1024字节
＃
＃单位不区分大小写，因此1GB 1Gb 1gB都相同。

################################## INCLUDES ###################################

＃在此处包含一个或多个其他配置文件。 如果您
＃具有可用于所有Redis服务器的标准模板，但也需要
＃自定义一些每服务器设置。 包含文件可以包括
＃个其他文件，因此请明智地使用此文件。
＃
＃注意，选项“ include”不会被命令“ CONFIG REWRITE”重写
＃来自admin或Redis Sentinel。 由于Redis始终使用最后处理的
＃将line作为配置指令的值，最好将include
＃在此文件的开头，以避免在运行时覆盖配置更改。
＃
＃如果您有兴趣使用include覆盖配置
＃选项，最好将include作为最后一行。
＃
# include /path/to/local.conf
# include /path/to/other.conf

################################## MODULES #####################################

＃在启动时加载模块。如果服务器无法加载模块
＃它会中止。可以使用多个loadmodule指令。
＃
＃loadmodule /path/to/my_module.so
＃loadmodule /path/to/other_module.so

################################## NETWORK #####################################

＃默认情况下，如果未指定“ bind”配置指令，则Redis侦听
＃用于来自主机上所有可用网络接口的连接。
＃使用以下命令可以仅收听一个或多个选定的接口
＃“ bind”配置指令，后接一个或多个IP地址。
＃
＃ 例子：
＃
＃bind 192.168.1.100 10.0.0.1
＃bind 127.0.0.1 :: 1
＃
＃~~~警告~~~如果运行Redis的计算机直接暴露于
＃互联网，绑定到所有接口都是危险的，并且会暴露
＃实例给互联网上的所有人。因此，默认情况下，我们取消注释
＃遵循bind指令，这将强制Redis仅在
＃IPv4环回接口地址（这意味着Redis将只能
＃接受来自运行该主机的同一主机的客户端连接。
＃
＃如果您确定要立即侦听所有界面
＃只需注意以下几行。
bind 127.0.0.1
＃保护模式是一层安全保护，以避免
＃访问和利用Internet上打开的Redis实例。
＃
＃启用保护模式时，如果：
＃
＃1）服务器未使用以下命令明确绑定到一组地址
＃“ bind”指令。
＃2）未配置密码。
＃
＃服务器仅接受来自客户端的连接，这些客户端从
＃IPv4和IPv6回送地址127.0.0.1和:: 1，并且来自Unix域
＃个套接字。
＃
＃默认情况下启用保护模式。 只有在以下情况下才应禁用它
＃您确定要让其他主机的客户端连接到Redis
＃即使未配置身份验证，也没有特定的接口集
＃使用“ bind”指令显式列出。
protected-mode yes
＃接受指定端口上的连接，默认为6379（IANA＃815344）。
＃如果指定了端口0，则Redis将不会在TCP套接字上侦听。
port 6379

＃TCP listen（）积压。
＃
＃在每秒请求数很高的环境中，您需要大量积压订单
＃避免客户端连接速度慢的问题。注意Linux内核
＃将默默地将其截断为/proc/sys/net/core/somaxconn的值，因此
＃确保同时提高somaxconn和tcp_max_syn_backlog的值
＃以获得理想的效果。
tcp-backlog 511

＃Unix套接字。
＃
＃指定用于侦听的Unix套接字的路径
＃传入连接。没有默认设置，因此Redis不会收听
＃如果未指定，则在UNIX套接字上。
＃
＃unixsocket /tmp/redis.sock
＃unixsocketperm 700

＃客户端闲置N秒后关闭连接（0禁用）
timeout 0

＃TCP保持活动状态。
＃
＃如果不为零，请使用SO_KEEPALIVE向不存在的客户端发送TCP ACK
通讯数量。这很有用，原因有两个：
＃
＃1）检测死亡的同伴。
＃2）强制中间的网络设备考虑连接
＃还活着。
＃
＃在Linux上，指定的值（以秒为单位）是用于发送ACK的时间段。
＃注意，关闭连接需要两倍的时间。
＃在其他内核上，期限取决于内核配置。
＃
＃此选项的合理值为300秒，这是新的
＃Redis默认从Redis 3.2.1开始。
tcp-keepalive 300
################################# TLS/SSL #####################################

＃默认情况下，禁用TLS / SSL。要启用它，请使用“ tls-port”配置
＃指令可用于定义TLS侦听端口。要在TLS上启用TLS
＃默认端口，使用：
＃
# port 0
# tls-port 6379

＃配置X.509证书和私钥以用于认证
＃服务器连接到连接的客户端，主服务器或集群对等服务器。这些文件应该是
＃PEM格式化。
＃
＃tls-cert-file redis.crt
＃tls-key-file redis.key

＃配置DH参数文件，启用Diffie-Hellman（DH）密钥交换。
＃
＃tls-dh-params-file redis.dh

＃配置CA证书捆绑包或目录以认证TLS / SSL
＃客户和同行。 Redis要求至少配置一个明确的配置
其中＃个，不会隐式使用系统范围的配置。
＃
＃tls-ca-cert-file ca.crt
＃tls-ca-cert-dir /etc/ssl/ certs

＃默认情况下，TLS端口上的客户端（包括副本服务器）是必需的
＃使用有效的客户端证书进行身份验证。
＃
＃如果指定为“ no”，则不需要也不接受客户端证书。
＃如果指定“可选”，则接受客户端证书，并且必须是
＃有效（如果提供），但不是必需的。
＃
# tls-auth-clients no
# tls-auth-clients optional

＃默认情况下，Redis副本不会尝试建立TLS连接
＃与它的主人。
＃
＃使用以下指令在复制链接上启用TLS。
＃
# tls-replication yes

＃默认情况下，Redis群集总线使用纯TCP连接。启用
＃用于总线协议的TLS，请使用以下指令：
＃
# tls-cluster yes

＃明确指定要支持的TLS版本。允许的值不区分大小写
＃并包含“ TLSv1”，“ TLSv1.1”，“ TLSv1.2”，“ TLSv1.3”（OpenSSL> = 1.1.1）或
＃任何组合。要仅启用TLSv1.2和TLSv1.3，请使用：
＃
# tls-protocols "TLSv1.2 TLSv1.3"

＃配置允许的密码。有关更多信息，请参见ciphers（1ssl）联机帮助页。
＃关于此字符串的语法。
＃
＃注意：此配置仅适用于<= TLSv1.2。
＃
# tls-protocols "TLSv1.2 TLSv1.3"

＃配置允许的TLSv1.3密码套件。有关更多信息，请参见ciphers（1ssl）联机帮助页。
＃有关此字符串的语法的信息，尤其是针对TLSv1.3的语法
＃密码套件。
＃
＃tls-ciphersuites TLS_CHACHA20_POLY1305_SHA256

＃选择密码时，请使用服务器的首选项而不是客户端
＃首选项。默认情况下，服务器遵循客户端的首选项。
＃
# tls-prefer-server-ciphers yes

＃默认情况下，启用了TLS会话缓存，以便更快，更便宜
＃支持它的客户端重新连接。使用以下指令禁用
＃缓存。
＃
# tls-session-caching no

＃更改默认的TLS会话缓存数。零值设置缓存
＃为无限大小。默认大小为20480。
＃
＃tls-session-cache-size 5000

＃更改缓存的TLS会话的默认超时时间。默认超时为300
＃秒。
＃
＃tls-session-cache-timeout 60
################################# GENERAL #####################################

＃默认情况下，Redis不会作为守护程序运行。如果需要，请使用“是”。
＃注意，Redis守护进程将在/var/run/redis.pid中写入一个pid文件。
daemonize no

＃如果您是从upstart或systemd运行Redis，则Redis可以与您的
＃监督树。选项：
＃无监督-无监督互动
＃受监督的新贵-通过将Redis置于SIGSTOP模式来指示新贵
＃在新贵的作业配置中需要“预期停止”
＃受监督的systemd-通过将READY = 1写入$ NOTIFY_SOCKET来发出信号systemd
＃有监督的自动-根据以下信息检测暴发户或系统方法
＃UPSTART_JOB或NOTIFY_SOCKET环境变量
＃注意：这些监视方法仅表示“过程已准备就绪”。
＃他们无法连续ping回您的主管。
supervised no

＃如果指定了pid文件，则Redis会在启动时将其写入指定位置
＃并在出口处将其删除。
＃
＃当服务器以非守护进程运行时，如果没有，则不创建pid文件
＃在配置中指定。守护服务器时，pid文件
＃即使未指定，也会使用，默认为“ /var/run/redis.pid”。
＃
＃尽力创建一个pid文件：如果Redis无法创建它
＃不会发生任何不良情况，服务器将启动并正常运行。
pidfile /var/run/redis_6379.pid

＃指定服务器的详细级别。
＃这可以是以下之一：
＃调试（很多信息，对于开发/测试很有用）
＃详细（很多很少有用的信息，但不会像调试级别那样混乱）
＃通知（适度冗长，可能是您想要的产品）
＃警告（仅记录非常重要/重要的消息）
loglevel notice

＃指定日志文件名。也可以使用空字符串强制
＃Redis登录到标准输出。请注意，如果您使用标准
＃输出用于日志记录但要守护进程，日志将发送到/ dev / null
logfile ""

＃要启用到系统记录器的日志记录，只需将'syslog-enabled'设置为yes，
＃并根据需要更新其他syslog参数。
# syslog-enabled no

＃指定系统日志标识。
＃syslog-ident redis

＃指定系统日志工具。必须是USER或在LOCAL0-LOCAL7之间。
＃syslog-facility local0

＃设置数据库数量。默认数据库是DB 0，可以选择
＃使用SELECT <dbid>在每个连接的基础上不同
＃dbid是介于0和'databases'-1之间的数字
databases 16

＃默认情况下，Redis仅在开始登录时才显示ASCII艺术徽标。
＃标准输出，如果标准输出是TTY。基本上这意味着
＃通常徽标仅在交互式会话中显示。
＃
＃但是可以强制4.0之前的行为并始终显示
＃通过将以下选项设置为yes，在启动日志中使用ASCII艺术徽标。
always-show-logo yes
############################## SNAPSHOTTING ################# ###############
＃
＃将数据库保存在磁盘上：
＃
＃  save <seconds> <changes>
＃
＃如果给定的秒数和给定的秒数都将保存数据库
＃针对数据库的写入操作数。
＃
＃在下面的示例中，行为将是保存：
＃在900秒（15分钟）后，如果至少更改了1个键
＃300秒（5分钟）后，如果至少更改了10个按键
＃60秒后，如果至少更改了10000个键
＃
＃注意：您可以通过注释掉所有“保存”行来完全禁用保存。
＃
＃也可以删除所有先前配置的保存
通过添加带有单个空字符串参数的save指令获得＃点
＃如以下示例所示：
＃
＃   save ""

save 900 1
save 300 10
save 60 10000

＃默认情况下，如果启用了RDB快照，Redis将停止接受写入
＃（至少一个保存点），并且最新的后台保存失败。
＃这将使用户（很难）意识到数据没有持久化
＃正确地放在磁盘上，否则没有人会注意到，有的机会
＃灾难将会发生。
＃
＃如果后台保存过程将再次开始工作，则Redis将
＃自动允许再次写入。
＃
＃但是，如果您已经设置了对Redis服务器的适当监视
＃和持久性，您可能要禁用此功能，以便Redis将
＃即使磁盘出现问题，仍继续照常工作，
＃权限，等等。
stop-writes-on-bgsave-error yes

＃转储.rdb数据库时使用LZF压缩字符串对象？
＃默认情况下启用压缩，因为它几乎总是胜利。
＃如果要在保存子项中保存一些CPU，请将其设置为“ no”，但是
＃如果您具有可压缩的值或键，则数据集可能会更大。
rdbcompression yes

＃从RDB版本5开始，在文件末尾放置了CRC64校验和。
＃这样可以使格式更耐腐败，但性能
＃在保存和加载RDB文件时点击支付（大约10％），因此您可以将其禁用
＃以获得最佳性能。
＃
＃在禁用校验和的情况下创建的RDB文件的校验和为零，这将使
＃告诉加载代码跳过检查。
rdbchecksum yes

＃转储数据库的文件名
dbfilename dump.rdb

＃在没有持久性的情况下删除复制中使用的RDB文件
＃启用。默认情况下，此选项是禁用的，但是在某些情况下
＃出于法规或其他安全方面的考虑，RDB文件保留在
＃由主服务器提供磁盘以提供副本，或由副本存储在磁盘上
＃为了加载它们以进行初始同步，应删除
＃ 尽快。请注意，此选项仅在同时具有AOF的实例中起作用
＃和RDB持久性禁用，否则将被完全忽略。
＃
＃一种获得相同效果的替代方法（有时更好）是
＃在主实例和副本实例上使用无盘复制。然而
＃对于副本，无盘并非总是一种选择。
rdb-del-sync-files no
＃工作目录。
＃
＃数据库将被写入此目录，并指定文件名
＃以上使用'dbfilename'配置指令。
＃
＃也将在此目录中创建“仅追加文件”。
＃
＃请注意，您必须在此处指定目录，而不是文件名。
dir ./
############################### REPLICATION ################ #################

＃主副本复制。 使用copyof作为Redis实例的副本
＃另一个Redis服务器。 尽快了解有关Redis复制的几件事。
#
#   +------------------+      +---------------+
#   |      Master      | ---> |    Replica    |
#   | (receive writes) |      |  (exact copy) |
#   +------------------+      +---------------+
#
＃1）Redis复制是异步的，但是您可以将master配置为
＃如果至少看起来没有连接，则停止接受写入
＃给定数量的副本。
＃2）Redis副本能够与以下服务器执行部分重新同步
＃master（如果复制链接丢失了相对较少的数量）
＃    时间。您可能需要配置复制积压大小（请参阅下一个
此文件的＃个部分），根据您的需要具有合理的价值。
＃3）复制是自动的，不需要用户干预。之后
＃网络分区副本自动尝试重新连接到主数据库
＃并与它们重新同步。
＃
# replicaof <masterip> <masterport>

＃如果主服务器受密码保护（使用“ requirepass”配置）
下面的＃指令）可以告诉副本在进行身份验证之前
＃启动复制同步过程，否则主服务器将
＃拒绝副本请求。
＃
# masterauth <master-password>
＃
＃但是，如果您使用的是Redis ACL（对于Redis版本，则还不够）
＃6或更高版本），并且默认用户无法运行PSYNC
＃命令和/或复制所需的其他命令。在这种情况下
＃更好地配置特殊用户以用于复制，并指定
＃masteruser配置如下：
＃
＃ masteruser <username>
＃
＃指定masteruser时，副本将根据其身份验证
＃master使用新的AUTH形式：AUTH <用户名> <密码>。

＃当副本失去与主数据库的连接时，或复制时
＃仍在进行中，副本可以以两种不同的方式起作用：
＃
＃1）如果复制副本服务过时数据设置为“是”（默认值），则复制副本将
＃仍然会回复客户的请求，可能包含过期的数据，或者
如果这是第一次同步，则＃数据集可能只是空的。
＃
＃2）如果copy-serve-stale-data设置为“ no”，则副本将回复
＃除以下命令外，所有命令均出现错误“正在与主机进行同步”：
＃INFO，REPLICAOF，AUTH，PING，SHUTDOWN，REPLCONF，角色，CONFIG，SUBSCRIBE，
＃UNSUBSCRIBE，PSUBSCRIBE，PUNSUBSCRIBE，PUBLISH，PUBSUB，COMMAND，POST，
＃主机和延迟。
＃
replica-serve-stale-data yes
＃您可以配置副本实例以接受或不接受写入。 反对
＃复制副本实例可能有助于存储一些临时数据（因为数据
与主服务器重新同步后，写在副本上的＃将很容易删除），但是
如果客户由于以下原因写信，＃也会引起问题。
＃配置错误。
＃
＃由于Redis 2.6默认情况下，副本是只读的。
＃
＃注意：只读副本并非旨在向不受信任的客户端公开
＃ 在网上。 它只是防止实例滥用的保护层。
＃默认仍然是只读副本导出所有管理命令
＃，例如CONFIG，DEBUG等。 在一定程度上您可以改善
＃使用'rename-command'隐藏所有副本的只读副本的安全性
＃管理/危险命令。
replica-read-only yes
＃复制同步策略：磁盘或套接字。
＃
＃无法继续执行新副本和重新连接副本
＃复制过程刚刚收到差异，需要做的是所谓的
＃“完全同步”。 RDB文件从主机传输到
＃个副本。
＃
＃传输可以两种不同的方式发生：
＃
＃1）支持磁盘：Redis主服务器创建一个新过程，该过程写入RDB
＃文件在磁盘上。之后文件由父级传输
＃逐步处理副本。
＃2）无盘：Redis主服务器创建一个新进程，该进程直接写入
＃将RDB文件复制到副本套接字，而完全不接触磁盘。
＃
＃使用磁盘支持的复制时，在生成RDB文件时，会有更多副本
＃可以在当前子级中排队并与RDB文件一起使用
＃生成RDB文件完成其工作。改为使用无盘复制
＃传输开始后，新的副本将进入队列，并且新
＃传输将在当前传输终止时开始。
＃
＃使用无盘复制时，主服务器等待可配置数量的
＃开始传输之前的时间（以秒为单位），希望倍数
＃副本将到达，并且传输可以并行化。
＃
＃使用慢速磁盘和快速（大带宽）网络，进行无盘复制
＃效果更好。
repl-diskless-sync no
＃启用无盘复制后，可以配置延迟
＃服务器等待以生成通过套接字传输RDB的子代
＃复制到副本。
＃
＃这很重要，因为一旦转移开始，就无法提供服务
＃个新副本到达，将排队等待下一次RDB传输，因此
＃服务器等待延迟以便让更多副本到达。
＃
＃延迟以秒为单位指定，默认为5秒。 禁用
＃完全将其设置为0秒，传输将尽快开始。
repl-diskless-sync-delay 5
＃------------------------------------------------- ----------------------------
＃警告：RDB无盘加载是实验性的。由于在此设置中，副本
＃不会立即将RDB存储在磁盘上，这可能会导致数据丢失
＃故障转移。 RDB无盘负载+ Redis模块不处理I / O读取也可能
＃导致Redis在初始同步期间发生I / O错误时中止
＃舞台与高手。仅在执行自己的操作时使用。
＃------------------------------------------------- ----------------------------
＃
＃复制副本可以直接从复制链接加载从复制链接读取的RDB
＃套接字，或将RDB存储到文件中，并在文件完全读取后读取
＃从主人那里收到的。
＃
＃在许多情况下，磁盘的速度比网络慢，并且存储和加载速度
＃RDB文件可能会增加复制时间（甚至会增加主数据库的复制时间
＃在写内存和从缓冲区中复制）。
＃但是，直接从套接字解析RDB文件可能意味着我们拥有
＃在完整的rdb被清除之前刷新当前数据库的内容
＃收到。因此，我们有以下选择：
＃
＃“ disabled”-不要使用无盘负载（首先将rdb文件存储到磁盘）
＃“ on-empty-db”-仅在完全安全时才使用无盘加载。
＃“ swapdb”-解析时在RAM中保留当前数据库内容的副本
＃直接从套接字获取数据。请注意，这需要
＃足够的内存，如果没有足够的内存，则可能会杀死OOM。
repl-diskless-load disabled
＃副本以预定义的间隔将PING发送到服务器。有可能
＃使用repl_ping_replica_period选项更改此间隔。默认值
＃值为10秒。
＃
＃repl-ping-replica-period 10

＃以下选项为以下项设置复制超时：
＃
＃1）从副本的角度来看，在SYNC期间进行批量传输I / O。
＃2）从副本（数据，Ping）的角度来看，主超时。
＃3）从主服务器角度来看，副本超时（REPLCONF ACK ping）。
＃
＃重要的是要确保该值大于该值
＃为repl-ping-replica-period指定，否则将检测到超时
＃每次主服务器和副本服务器之间的流量较低时。默认值
＃值为60秒。
＃
＃repl-timeout 60

＃在SYNC之后禁用副本套接字上的TCP_NODELAY？
＃
＃如果选择“是”，则Redis将使用较少数量的TCP数据包，并且
＃减少将数据发送到副本的带宽。但这可能会增加
＃出现在副本端的数据，最长40毫秒，
＃Linux内核使用默认配置。
＃
＃如果选择“否”，则数据在副本端出现的延迟将
＃减少但更多带宽将用于复制。
＃
＃默认情况下，我们针对低延迟进行了优化，但在流量非常高的情况下
＃或在距离主副本和副本很多跳的情况下，将其设置为“是”可能
＃成为一个好主意。
repl-disable-tcp-nodelay no
＃设置复制积压大小。积压是积累的缓冲区
＃副本断开连接一段时间后的副本数据，以便当
＃复制副本想重新连接，通常不需要完全重新同步，但是
＃部分重新同步就足够了，只需将部分数据传递给副本
＃断开连接时错过了。
＃
＃复制积压越大，副本可以承受的时间越长
＃断开连接，以后可以执行部分​​重新同步。
＃
＃仅在连接至少一个副本时分配积压。
＃
＃repl-backlog-size 1mb

＃在主服务器一段时间内没有连接的副本后，待办事项将为
＃被释放。以下选项可配置所需的秒数
＃从过去的副本断开连接的时间开始，进行积压
＃缓冲区被释放。
＃
＃注意副本不会释放积压的超时，因为它们可能是
＃稍后晋升为硕士，应该能够正确地“部分
＃reynchronize”与其他副本：因此它们应始终积累积压。
＃
＃值0表示从不释放积压。
＃
＃repl-backlog-ttl 3600

＃副本优先级是Redis在INFO中发布的整数
＃输出。 Redis Sentinel使用它来选择要升级的副本
＃如果主服务器不再正常工作，则进入主服务器。
＃
＃优先级低的副本更适合升级，因此
＃例如，如果有三个副本的优先级分别为10、100、25 Sentinel
＃将选择优先级为10的优先级最低的那个。
＃
＃但是，特殊优先级0表示副本无法执行
＃为主角色，因此优先级为0的副本永远不会被
＃Redis前哨升级。
＃
＃默认情况下，优先级为100。
replica-priority 100
＃如果少于以下数量，则主机可能会停止接受写入
已连接N个副本，延迟小于或等于M秒。
＃
＃N个副本必须处于“联机”状态。
＃
＃必须以秒为单位的滞后时间必须小于等于指定值
＃从副本接收到的最后ping，通常每秒发送一次。
＃
＃此选项不能保证N个副本将接受写入，但是
＃将限制在丢失副本的情况下暴露窗口，以防副本数量不足
＃可用，以指定的秒数为单位。
＃
＃例如，需要至少3个滞后<= 10秒的副本，请使用：
＃
# min-replicas-to-write 3
# min-replicas-max-lag 10
＃
＃将一个或另一个设置为0将禁用该功能。
＃
＃默认情况下，min-replicas-to-write设置为0（禁用功能），并且
＃min-replicas-max-lag设置为10。

＃Redis主服务器能够列出连接的地址和端口
＃以不同方式复制。例如，“ INFO复制”部分
＃提供此信息，除其他工具外，该信息还用于
＃Redis Sentinel以发现副本实例。
＃此信息可用的另一个地方是
＃主机的“ ROLE”命令。
＃
＃副本通常报告的列出的IP地址和端口为
通过以下方式获得的＃：
＃
＃IP：通过检查对等地址自动检测到该地址
副本用于与主服务器连接的套接字的编号。
＃
＃端口：复制过程中副本通过该端口进行通信
＃握手，通常是副本使用的端口
＃监听连接。
＃
＃但是，当端口转发或网络地址转换（NAT）为
＃使用，实际上可以通过不同的IP和端口访问副本
＃对。副本可以使用以下两个选项，以便
＃向其主人报告一组特定的IP和端口，以便同时显示INFO
＃和ROLE将报告这些值。
＃
＃如果您只需要覆盖两个选项，则无需同时使用这两个选项
＃端口或IP地址。
＃
# replica-announce-ip 5.5.5.5
# replica-announce-port 1234
#############################按键跟踪################# ################

＃Redis为客户端的值缓存实现服务器辅助的支持。
＃使用无效表来实现，该表记住
＃1600万个插槽，哪些客户端可能具有某些密钥子集。反过来
＃用于将无效消息发送到客户端。请
＃检查此页面以了解有关该功能的更多信息：
＃
＃https://redis.io/topics/client-side-caching
＃
＃为客户端启用跟踪时，将假定所有只读查询
＃要缓存：这将迫使Redis在无效信息中存储信息
＃表。修改密钥后，此类信息将被清除，并且
＃无效消息发送到客户端。但是，如果工作量为
＃在读取中占主导地位，Redis可以按顺序使用越来越多的内存
＃跟踪许多客户端获取的密钥。
＃
＃因此，可以为
＃无效表。默认情况下将其设置为1M的密钥，并且一旦达到此限制
到达＃，Redis将开始移出失效表中的键
＃即使它们没有被修改，只是为了回收内存：这将依次
＃强制客户端使缓存的值无效。基本上是桌子
＃最大大小是您要花费的服务器内存之间的权衡
＃端跟踪有关谁缓存了什么以及客户端功能的信息
＃在内存中保留缓存的对象。
＃
＃如果将该值设置为0，则表示没有限制，Redis将
＃在失效表中保留所需数量的键。
＃在“统计信息”信息部分中，您可以找到有关
在每个给定时刻，失效表中的＃个键。
＃
＃注意：在广播模式下使用键跟踪时，不使用任何内存
＃在服务器端，因此此设置无用。
＃
＃tracking-table-max-keys 1000000
################################# SECURITY ################ ####################

＃警告：由于Redis速度非常快，外部用户可以尝试
＃在现代机器上每秒可读取100万个密码。这意味着你
＃应该使用非常强的密码，否则它们很容易被破解。
＃注意，因为密码实际上是客户端之间的共享机密
＃和服务器，并且不应由任何人记住密码
＃可以很容易地是来自/ dev / urandom或其他类型的长字符串，因此可以使用
＃长而难以猜测的密码，无法进行暴力攻击。

＃Redis ACL用户的定义如下：
＃
＃用户<用户名> ... ACL规则...
＃
＃ 例如：
＃
＃用户工作者+ @ list + @ connection〜jobs：* on> ffa9203c493aa99
＃
＃特殊用户名“默认”用于新连接。如果这个用户
＃具有“ nopass”规则，那么新连接将立即得到认证
＃作为“默认”用户，而无需通过
＃AUTH命令。否则，如果未将“默认”用户标记为“ nopass”
＃连接将以未经身份验证的状态开始，并且需要
＃AUTH（或HELLO命令AUTH选项），以便进行身份验证和
＃开始工作。
＃
＃描述用户可以执行的操作的ACL规则如下：
＃
＃on启用用户：可以以该用户身份进行身份验证。
＃off禁用用户：不再可能进行身份验证
＃与该用户，但是已经通过身份验证的连接
＃仍然可以使用。
＃+ <命令>允许执行该命令
＃-<命令>禁止执行该命令
＃+ @ <category>允许执行此类中的所有命令
＃具有有效类别的名称，例如@ admin，@ set，@ sortedset，...
＃依此类推，请参阅server.c文件中的完整列表，其中
＃描述并定义了Redis命令表。
＃特殊类别@all表示所有命令，但当前
＃存在于服务器中，以后会加载
＃通过模块。
＃+ <command> | subcommand允许使用否则的特定子命令
＃禁用命令。请注意，此表格不是
＃可以像-DEBUG | SEGFAULT一样被否定，但是
＃仅以“ +”开头的添加剂。
＃allcommands + @ all的别名。请注意，这意味着执行的能力
＃所有将来通过模块系统加载的命令。
＃nocommands-@ all的别名。
＃〜<pattern>添加可以在其中提及的键的模式
＃条命令。例如〜*允许所有键。图案
＃是一种球形样式的模式，类似于KEYS之一。
＃可以指定多个模式。
＃allkeys〜*的别名
＃resetkeys刷新允许的键模式列表。
＃> <密码>将此密码添加到用户的有效密码列表中。
＃例如> mypass将“ mypass”添加到列表中。
＃此指令清除“ nopass”标志（请参阅下文）。
＃<< password>从有效密码列表中删除此密码。
＃nopass删除用户的所有设置密码，然后用户
＃被标记为不需要密码：这意味着每个
＃密码将对此用户无效。如果该指令是
＃用于默认用户，每个新连接都会
＃立即通过默认用户进行身份验证，而无需
＃任何必需的显式AUTH命令。注意“ resetpass”
＃指令将清除此条件。
＃resetpass刷新允许的密码列表。而且去除
＃“ nopass”状态。在“ resetpass”之后，用户没有关联
＃个密码，没有添加就无法进行身份验证
＃一些密码（或稍后将其设置为“ nopass”）。
＃reset执行以下操作：resetpass，resetkeys，off，
＃-@ all。用户立即返回到相同的状态
＃创建后。
＃
＃ACL规则可以以任何顺序指定：例如，您可以以
＃个密码，然后是标志或密钥模式。但是请注意，添加剂
＃和减法规则将根据顺序更改含义。
＃例如，请参见以下示例：
＃
＃用户alice在+ @ all -DEBUG〜*> somepassword上
＃
＃这将允许“驴友”使用所有命令，但
＃DEBUG命令，因为+ @ all将所有命令添加到命令集中
＃alice可以使用，后来删除了DEBUG。但是，如果我们颠倒顺序
如果有两个ACL规则，结果将有所不同：
＃
＃用户alice在-DEBUG + @ all〜*> somepassword
＃
＃现在，当alice的允许集中还没有命令时，DEBUG被删除。
＃命令，以后添加了所有命令，因此用户将能够
＃执行所有操作。
＃
＃基本上，ACL规则是从左到右处理的。
＃
＃有关ACL配置的更多信息，请参阅
＃Redis网站位于https://redis.io/topics/acl

＃ACL日志
＃
＃ACL日志跟踪失败的命令和关联的身份验证事件
＃与ACL。 ACL日志可用于对阻止的失败命令进行故障排除
＃通过ACL。 ACL日志存储在内存中。您可以使用以下方法回收内存
＃ACL日志重置。在下面定义ACL日志的最大条目长度。
acllog-max-len 128
＃使用外部ACL文件
＃
＃可以在此文件中代替在此处配置用户
＃一个仅列出用户的独立文件。两种方法不能混合使用：
＃如果您在此处配置用户并同时激活外部
＃ACL文件，服务器将拒绝启动。
＃
＃外部ACL用户文件的格式与
＃在redis.conf中用于描述用户的格式。
＃
＃aclfile /etc/redis/users.acl

＃重要说明：从Redis 6开始“ requirepass”只是一种兼容性
在新的ACL系统之上的＃层。选项效果将只是设置
＃默认用户的密码。客户仍将使用
＃像往常一样使用AUTH <password>，或更明确地使用AUTH default <password>
＃如果它们遵循新协议：两者都会起作用。
＃
＃requirepass foobared

＃命令重命名（不建议使用）。
＃
＃------------------------------------------------- -----------------------
＃警告：尽可能避免使用此选项。而是使用ACL移除
＃个来自默认用户的命令，并将它们仅放置在您的某些管理员用户中
＃创建用于管理目的。
＃------------------------------------------------- -----------------------
＃
＃可以在共享中更改危险命令的名称
＃ 环境。例如，可以将CONFIG命令重命名为某些内容
＃难以猜测，因此仍可供内部使用工具使用
＃但不适用于一般客户。
＃
＃示例：
＃
＃重命名命令CONFIG b840fc02d524045429941cc15f59e41cb7be6c52
＃
＃也可以通过将命令重命名为命令来完全杀死命令
＃一个空字符串：
＃
＃rename-command CONFIG ""
＃
＃请注意，更改登录到
＃AOF文件或传输到副本可能会导致问题。
################################# CLIENTS ############## ######################

＃设置同时连接的最大客户端数。 默认
＃此限制设置为10000个客户端，但是如果Redis服务器不是
＃能够配置进程文件限制以允许指定的限制
＃允许的最大客户端数设置为当前文件限制
＃减32（因为Redis保留了一些文件描述符供内部使用）。
＃
＃一旦达到限制，Redis将关闭所有新发送的连接
＃错误“达到最大客户端数”。
＃
＃重要提示：使用Redis群集时，最大连接数也是
＃与集群总线共享：集群中的每个节点将使用两个
＃个连接，一个传入，另一个传出。 重要的是
＃如果群集很大，则相应地限制。
＃
＃maxclients 10000
＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃ 内存管理 ＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃ ##############

＃设置内存使用限制为指定的字节数。
＃当达到内存限制时，Redis将尝试删除密钥
＃根据选择的驱逐策略（请参阅maxmemory-policy）。
＃
＃如果Redis无法根据策略删除密钥，或者策略为
＃设置为'noeviction'，Redis将开始回复命令错误
＃将使用更多的内存，例如SET，LPUSH等，并将继续
＃回复诸如GET之类的只读命令。
＃
＃当将Redis用作LRU或LFU缓存时，通常使用此选项
＃设置实例的硬盘限制（使用“ noeviction”策略）。
＃
＃警告：如果您将副本附加到实例上且启用了maxmemory，
＃减去提供副本所需的输出缓冲区的大小
＃从已用的内存数量开始，以便网络问题/重新同步
＃不触发退出键的循环，反过来输出
＃复制副本缓冲区已满，有被删除的密钥DEL触发了删除
＃更多的键，依此类推，直到数据库完全清空。
＃
＃简而言之...如果您附加了副本，建议您设置一个较低的
＃maxmemory的限制，以便系统上有一些可用的RAM用于复制
＃个输出缓冲区（但如果策略为“ noeviction”，则不需要此缓冲区）。
＃
＃maxmemory <bytes>

＃MAXMEMORY POLICY：maxmemory时，Redis将如何选择要删除的内容
＃ 到达了。您可以从以下行为中选择一种：
＃
＃volatile-lru->使用近似的LRU驱逐，只有具有过期集的密钥。
＃allkeys-lru->使用近似的LRU退出任何密​​钥。
＃volatile-lfu->使用近似的LFU驱逐，只有具有过期集的键。
＃allkeys-lfu->使用近似的LFU退出任何密​​钥。
＃volatile-random->删除具有过期集的随机密钥。
＃allkeys-random->删除随机密钥，任何密钥。
＃volatile-ttl->删除最接近到期​​时间（较小的TTL）的密钥
＃noeviction->不要逐出任何东西，只需在写操作中返回错误。
＃
＃LRU表示最近最少使用
＃LFU表示最少使用
＃
＃LRU，LFU和volatile-ttl均使用近似值实现
＃随机算法。
＃
＃注意：使用上述任何策略，Redis都会在写入时返回错误
＃操作，如果没有合适的退出键。
＃
＃在撰写本文时，这些命令是：set setnx setex append
＃incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd
＃sinter sinterstore sunion sunionstore sdiff sdiffstore zadd锌锌合金
＃zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby
＃getset mset msetnx exec排序
＃
＃默认为：
＃
＃maxmemory-policy noeviction
＃LRU，LFU和最小TTL算法不是精确算法，而是近似算法
＃算法（以节省内存），因此您可以对其进行调整以提高速度或
＃ 准确性。默认情况下，Redis将检查五个键并选择一个
＃最近最少使用，您可以使用以下方法更改样本大小
＃配置指令。
＃
＃默认值5产生足够好的结果。 10非常接近
＃真正的LRU，但消耗更多的CPU。 3更快，但不是很准确。
＃
＃maxmemory-samples 5

＃从Redis 5开始，默认情况下副本将忽略其maxmemory设置
＃（除非在故障转移后或手动提升为主节点）。它的意思是
＃退出密钥将仅由主机处理，发送
＃DEL命令作为副本在主控端退出到副本。
＃
＃此行为可确保母版和副本保持一致，并且通常
＃您想要的内容，但是如果副本是可写的，或者您想要副本
＃具有不同的内存设置，并且您确定执行了所有写操作
＃到副本是幂等的，则可以更改此默认值（但请确保
＃了解您在做什么。
＃
＃请注意，由于默认情况下该副本不会退出，因此它可能最终会使用更多副本
＃内存比通过maxmemory设置的内存多（某些缓冲区可能
＃在副本上更大，否则数据结构有时可能会占用更多内存
＃等）。因此，请确保您监视副本并确保它们
＃具有足够的内存，永远不会在内存不足之前达到真正的内存不足状态
＃master达到配置的maxmemory设置。
＃
＃replica-ignore-maxmemory yes

＃Redis通过两种方式回收过期的密钥：在访问这些密钥时
＃发现已过期，并且在后台，也就是所谓的
＃“活动的过期密钥”。密钥空间被缓慢地交互扫描
＃寻找可回收的过期密钥，以便可以释放内存
过期的密钥数量，将在短期内不再访问。
＃
＃到期周期的默认工作量将尝试避免超过
＃百分之十的过期密钥仍在内存中，并将尝试避免消耗
＃超过总内存的25％，并增加系统延迟。然而
＃可以增加通常设置为的过期“努力”
＃“ 1”，取更大的值，最大取值“ 10”。在最大值
＃系统将使用更多的CPU，周期更长（从技术上讲，
＃更高的延迟），并且可以容忍更少的已过期密钥仍然存在
＃在系统中。在内存，CPU和延迟之间进行权衡。
＃
＃active-expire-effort 1
############################ LAZY FREEING #################### #################

＃Redis有两个删除键的原语。一个叫做DEL，是一个阻塞
＃删除对象。这意味着服务器停止处理新命令
＃为了在同步中回收与对象关联的所有内存
＃ 方式。如果删除的键与小对象相关联，则需要时间
＃为了执行DEL命令非常小，可与大多数其他设备相比
＃Redis中的O（1）或O（log_N）命令。但是，如果密钥与
＃包含数百万个元素的聚合值，服务器可以阻止
＃长时间（甚至几秒钟）以完成操作。
＃
＃由于上述原因，Redis还提供了非阻塞删除原语
＃，例如UNLINK（非阻塞DEL）和FLUSHALL的ASYNC选项，以及
＃FLUSHDB命令，以便在后台回收内存。这些命令
＃在固定时间内执行。另一个线程将逐步释放
＃尽可能快地在后台对象。
＃
＃FLUSHALL和FLUSHDB的DEL，UNLINK和ASYNC选项是用户控制的。
＃由应用程序的设计决定何时是一个好的
＃使用一个或另一个的想法。但是，Redis服务器有时必须
＃删除键或刷新整个数据库，这是其他操作的副作用。
＃特别是Redis会独立于用户调用中的对象删除对象
＃以下方案：
＃
＃1）驱逐时，由于maxmemory和maxmemory策略配置，
＃以便为新数据腾出空间，而无需遍历指定的
＃内存限制。
＃2）由于过期：当一个密钥具有关联的生存时间（请参见
＃EXPIRE命令）必须从内存中删除。
＃3）由于将数据存储在键上的命令的副作用，该键可能会
＃    已经存在。例如，RENAME命令可能会删除旧密钥
＃内容被另一内容替换时。同样的SUNIONSTORE
＃或带有STORE选项的SORT可能会删除现有密钥。 SET命令
＃本身会删除指定密钥的所有旧内容以进行替换
＃使用指定的字符串。
＃4）在复制过程中，当副本使用以下命令执行完全重新同步时：
＃它的主人，整个数据库的内容被删除以便
＃加载刚传输的RDB文件。
＃
＃在上述所有情况下，默认设置都是以阻止方式删除对象，
＃就像是否调用了DEL。但是，您可以专门配置每种情况
＃以便以非阻塞方式释放内存，例如UNLINK
使用以下配置指令调用了＃。
lazyfree-lazy-eviction no
lazyfree-lazy-expire no
lazyfree-lazy-server-del no
replica-lazy-flush no
＃对于替换用户代码DEL调用的情况也是可能的
＃用UNLINK调用不容易，修改DEL的默认行为
使用以下配置，使＃命令的行为与UNLINK完全相同
＃指令：
lazyfree-lazy-user-del no
############################## THREADED I / O ############## ###################

＃Redis主要是单线程的，但是有某些线程
＃操作，例如UNLINK，缓慢的I / O访问和其他
＃在侧线程上执行。
＃
＃现在也可以处理Redis客户端套接字的读写
＃在不同的I / O线程中。由于特别是写作如此缓慢，通常
＃Redis用户使用流水线以加快Redis的性能
＃核心，并产生多个实例以扩展规模。使用I / O
＃线程可以轻松地将Redis加速两次，而无需诉诸
＃对实例进行流水线处理或分片。
＃
＃默认情况下禁用线程，我们建议仅在计算机中启用它
＃至少具有4个或更多内核，剩下至少一个备用内核。
＃使用8个以上的线程不太会有帮助。我们也建议使用
＃仅在确实存在性能问题的情况下，使用Redis进行线程化的I / O
＃个实例可以使用很大一部分CPU时间，否则
＃使用此功能毫无意义。
＃
＃因此，例如，如果您有四个内核的盒子，请尝试使用2或3个I / O
＃个线程，如果您有8个核心，请尝试使用6个线程。为了
＃enable I / O线程使用以下配置指令：
＃
＃io-threads 4
＃
＃将io-threads设置为1只会照常使用主线程。
＃启用I / O线程后，我们仅使用线程进行写操作，即
＃线程化write（2）系统调用并将客户端缓冲区传输到
＃插座。但是，也可以启用读取和
＃使用以下配置指令解析协议，方法是设置
＃它是：
＃
＃io-threads-do-reads no
＃
＃通常，线程读取无济于事。
＃
＃注意1：无法在运行时通过以下方式更改此配置指令
＃配置设置当SSL为时，Aso此功能当前不起作用
＃启用。
＃
＃注意2：如果要使用redis-benchmark测试Redis加速，请
＃确保您也使用线程化模式运行基准测试本身
＃--threads选项以匹配Redis线程数，否则您将不会
＃能够注意到改进。

########################### KERNEL OOM CONTROL #################### ###########

＃在Linux上，可以向内核提示OOM杀手级进程
＃内存不足时应先被杀死。
＃
＃启用此功能可使Redis主动控制oom_score_adj值
＃取决于其所有流程。默认分数将
＃尝试先杀死后台子进程，然后
＃个副本在高手面前被杀死。
oom-score-adj no
＃使用oom-score-adj时，此指令控制使用的特定值
＃用于主，副本和后台子进程。 值范围-1000至
＃1000（越高意味着越有可能被杀死）。
＃
＃非特权进程（不是root，并且没有CAP_SYS_RESOURCE功能）
＃可以自由增加其值，但不能将其降低到其初始值以下
＃个设置。
＃
＃服务器使用相对于oom_score_adj的初始值的值
＃开始。 由于初始值通常为0，因此它们通常会与
＃个绝对值。
oom-score-adj-values 0 200 800
############################ APPEND ON MODE ################# ##############

＃默认情况下，Redis异步将数据集转储到磁盘上。此模式是
＃在许多应用程序中都足够好，但是Redis进程或
＃停电可能会导致几分钟的写入丢失（取决于
＃配置的保存点）。
＃
＃仅附加文件是一种替代的持久性模式，可提供
＃更好的耐久性。例如使用默认数据fsync策略
＃（请参阅配置文件中的后面部分），Redis可能仅丢失一秒钟的写操作。
＃戏剧性事件，例如服务器断电，或者一次写入（如果有的话）
＃Redis进程本身发生了错误，但是操作系统是
＃仍能正常运行。
＃
＃可以同时启用AOF和RDB持久性，而不会出现问题。
＃如果启动时启用了AOF，则Redis将加载AOF，即文件
＃具有更好的耐久性保证。
＃
＃请检查http://redis.io/topics/persistence以获取更多信息。

appendonly no

＃仅附加文件的名称（默认值：“ appendonly.aof”）

appendfilename "appendonly.aof"

＃fsync（）调用告诉操作系统实际在磁盘上写入数据
＃而不是等待输出缓冲区中的更多数据。某些操作系统会真正刷新
＃磁盘上的数据，某些其他操作系统将尝试尽快进行处理。
＃
＃Redis支持三种不同的模式：
＃
＃否：不要fsync，只要让OS在需要时刷新数据即可。快点。
＃always：每次仅写入追加日志后的fsync。慢，最安全。
＃everysec：每秒仅同步一次fsync。妥协。
＃
＃默认为“ everysec”，因为通常是
＃速度和数据安全。您可以自行决定是否可以放松
＃“ no”将使操作系统在以下情况时刷新输出缓冲区
＃它希望获得更好的性能（但如果您能够接受
＃有些数据丢失会考虑默认的持久化模式（即快照），
＃或相反，请使用“总是”，该速度非常慢，但比
＃每秒钟。
＃
＃更多详细信息，请查看以下文章：
＃http://antirez.com/post/redis-persistence-demystified.html
＃
＃如果不确定，请使用“ everysec”。

# appendfsync always
appendfsync everysec
# appendfsync no

＃当AOF fsync策略设置为always或everysec，并且有背景
＃保存过程（后台保存或AOF日志后台重写）为
＃在某些Linux配置中，对磁盘执行大量I / O
＃Redis可能在fsync（）调用中阻塞的时间过长。请注意，没有针对
＃当前，因为即使在其他线程中执行fsync也会阻塞
＃我们的同步write（2）调用。
＃
＃为了减轻此问题，可以使用以下选项
＃可以防止在主进程中调用fsync（）时
＃BGSAVE或BGREWRITEAOF正在进行中。
＃
＃这意味着当另一个孩子正在保存时，Redis的持久性是
＃与“ appendfsync none”相同。实际上，这意味着
＃在最坏的情况下可能会丢失多达30秒的日志记录（使用
＃默认Linux设置）。
＃
＃如果您有延迟问题，请将其设为“是”。否则将其保留为
从耐久性的角度来看，“＃”是最安全的选择。

no-appendfsync-on-rewrite no

＃自动重写仅附加文件。
＃Redis能够自动重写隐式调用的日志文件
当AOF日志大小增加指定百分比时，＃BGREWRITEAOF。
＃
＃这是这样的：Redis会记住AOF文件的大小。
＃最新重写（如果自重新启动以来未发生任何重写，则为
＃使用启动时的AOF）。
＃
＃将此基本大小与当前大小进行比较。如果当前大小是
＃大于指定的百分比，将触发重写。也
＃您需要指定要重写的AOF文件的最小大小，这
＃即使在百分比增加的情况下也可以避免重写AOF文件
＃已达到，但仍然很小。
＃
＃指定零百分比以禁用自动AOF
＃重写功能。

auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

＃在Redis的最后发现AOF文件被截断
＃启动过程，当AOF数据重新加载到内存中时。
＃当运行Redis的系统时可能会发生
＃崩溃，尤其是在没有安装ext4文件系统的情况下
＃data = ordered选项（但是Redis本身不会发生这种情况
＃崩溃或中止，但操作系统仍可正常运行）。
＃
＃Redis可以在发生这种情况时退出并显示错误，也可以加载
＃尽可能的数据（现在是默认值），如果找到AOF文件则开始
＃在末尾被截断。以下选项控制此行为。
＃
＃如果aof-load-truncated设置为yes，则会加载截短的AOF文件并
＃Redis服务器开始发出日志以通知用户该事件。
＃否则，如果该选项设置为no，服务器将中止运行一个错误
＃并拒绝启动。当选项设置为无，用户需要
＃在重新启动之前使用“ redis-check-aof”实用程序修复AOF文件
＃ 服务器。
＃
＃请注意，如果在中间发现AOF文件已损坏
＃服务器仍将退出并出现错误。 此选项仅在以下情况下适用
＃Redis将尝试从AOF文件中读取更多数据，但字节数不足
＃将被发现。
aof-load-truncated yes

＃重写AOF文件时，Redis可以在
＃AOF文件可加快重写和恢复速度。 启用此选项时
重写的AOF文件上的＃由两个不同的节组成：
＃
＃[RDB文件] [AOF尾巴]
＃
＃加载时，Redis会识别AOF文件以“ REDIS”开头
＃字符串并加载带前缀的RDB文件，然后继续加载AOF
＃ 尾巴。
aof-use-rdb-preamble yes
############################## LUA SCRIPTING ################ ###############

＃Lua脚本的最大执行时间（以毫秒为单位）。
＃
＃如果达到最大执行时间，Redis将记录脚本
＃在最长允许时间后仍在执行，并将开始执行
＃回复有错误的查询。
＃
＃当长时间运行的脚本超过最大执行时间时，仅
＃SCRIPT KILL和SHUTDOWN NOSAVE命令可用。 第一个可以是
＃用于停止尚未调用任何写命令的脚本。 第二
＃是在执行写命令的情况下关闭服务器的唯一方法
＃已由脚本发出，但用户不想等待自然
＃终止脚本。
＃
＃将其设置为0或负值以无警告地无限执行。
lua-time-limit 5000
############################### REDIS CLUSTER ################ ###############

＃普通Redis实例不能属于Redis集群；只有节点
＃在集群节点可以的情况下启动。为了启动一个Redis实例
＃cluster node使群集支持取消注释以下内容：
＃
＃cluster-enabled yes

＃每个群集节点都有一个群集配置文件。该文件不是
＃旨在手动编辑。它由Redis节点创建和更新。
＃每个Redis群集节点都需要一个不同的群集配置文件。
＃确保在同一系统上运行的实例没有
＃重叠的集群配置文件名。
＃
＃cluster-config-file nodes-6379.conf

＃群集节点超时是节点必须无法访问的毫秒数
＃将其视为失败状态。
＃其他大多数内部时间限制是节点超时的倍数。
＃
＃cluster-node-timeout 15000

＃发生故障的主服务器的副本将避免在其数据出现时启动故障转移
＃看起来太旧了。
＃
＃没有简单的方法可以使副本实际具有精确的度量
＃它的“数据年龄”，因此执行以下两项检查：
＃
＃1）如果有多个副本可以进行故障转移，则它们交换消息
＃为了尝试使副本具有最佳优势
＃复制偏移（已处理来自主服务器的更多数据）。
＃副本将尝试按偏移量获得排名，并应用于开始
故障转移的数量与它们的等级成正比的延迟。
＃
＃2）每个副本都计算与
＃它的主人。这可以是最后收到的ping或命令（如果主服务器
＃仍处于“已连接”状态），或者自
＃与主服务器断开连接（如果复制链接当前断开）。
＃如果最后一次交互太旧，副本将不会尝试故障转移
＃。
＃
＃用户可以调整点“ 2”。具体来说，副本将无法执行
＃故障转移（如果自从与主机进行最后一次交互以来）
＃经过的次数大于：
＃
＃（节点超时*集群副本有效性因子）+ repl-ping-replica-period
＃
＃例如，如果节点超时为30秒，并且cluster-replica-validity-factor
＃为10，并假设默认的repl-ping-replica-period为10秒，则
＃副本如果无法与主副本通信，则不会尝试进行故障转移
＃超过310秒。
＃
＃较大的群集副本有效性因子可能允许数据过旧的副本进行故障转移
＃master，但值太小可能会阻止群集执行以下操作：
＃完全选择一个副本。
＃
＃为了获得最大可用性，可以设置cluster-replica-validity-factor
＃的值为0，这意味着副本将始终尝试对
＃master，无论他们上次与master互动的时间如何。
＃（但是，他们将始终尝试按比例分配延迟
＃偏移排名）。
＃
＃零是唯一能够保证所有分区恢复正常的值
＃群集将始终能够继续。
＃
＃cluster-replica-validity-factor 10

＃群集副本能够迁移到孤立的主数据库（即主数据库）
＃没有可用的副本。这提高了集群能力
＃抵抗失败，否则孤立的主节点无法进行故障转移
＃如果没有可用的副本则失败。
＃
＃仅当仍然存在至少一个副本时，副本服务器才会迁移到孤立的主服务器
＃给定其旧主副本的其他工作副本的数量。这个号码
＃是“移民壁垒”。迁移障碍为1表示副本
＃仅在其主数据库至少有其他1个工作副本时才会迁移
＃依此类推。它通常反映出每个副本所需的副本数
＃集群中的master。
＃
＃默认为1（仅当主服务器保留至少
＃一个副本）。要禁用迁移，只需将其设置为非常大的值即可。
＃可以设置为0，但仅在调试和危险时有用
＃生产中。
＃
＃cluster-migration-barrier 1

＃默认情况下，Redis群集节点如果检测到它们，则停止接受查询
＃至少是一个未显示的哈希槽（没有可用的节点为其提供服务）。
＃如果集群部分关闭，则采用这种方式（例如，一定范围的哈希槽）
＃不再包含）所有群集最终将变得不可用。
＃再次覆盖所有插槽后，它将自动返回可用状态。
＃
＃但是有时您希望集群的子集正常工作，
＃继续接受对仍然存在的键空间部分的查询
＃覆盖。为此，只需设置cluster-require-full-coverage
＃选项为否。
＃
＃cluster-require-full-coverage yes

＃此选项设置为yes时，可防止副本尝试对其进行故障转移
＃在主服务器故障期间的主服务器。但是主控仍然可以执行
＃手动故障转移（如果被迫这样做）。
＃
＃这在不同的情况下很有用，尤其是在n多个的情况
＃数据中心操作，如果不希望的话，我们希望一侧永远不会升级
＃如果发生直流故障。
＃
＃cluster-replica-no-failover no

＃此选项设置为yes时，允许节点在
＃集群处于关闭状态，只要它认为自己拥有插槽即可。
＃
＃这在两种情况下很有用。第一种情况是当应用程序
＃在节点故障或网络分区期间不需要数据的一致性。
＃缓存的一个例子，只要节点有数据
＃应该能够提供服务。
＃
＃第二个用例用于不符合建议的配置
＃三个分片，但要启用集群模式并在以后扩展。一种
＃1或2分片配置中的master中断导致对
＃没有设置此选项的整个群集，设置了该选项后，只会发生写中断。
＃如果没有法定人数的主持人，则插槽所有权不会自动更改。
＃
＃ cluster-allow-reads-when-down no

＃为了设置您的集群，请确保阅读文档
＃可从http://redis.io网站获得。

######################### CLUSTER DOCKER/NAT support ################### #####

＃在某些部署中，Redis群集节点地址发现失败，因为
＃个地址是NAT-ted或因为端口已转发（典型情况是
＃Docker和其他容器）。
＃
＃为了使Redis Cluster在这样的环境中工作，
＃每个节点都知道需要其公共地址的配置。的
＃以下两个选项用于此范围，分别是：
＃
# * cluster-announce-ip
# * cluster-announce-port
# * cluster-announce-bus-port
＃
＃每个命令都向节点指示其地址，客户端端口和集群消息
＃总线端口。然后将信息发布在总线数据包的标题中
＃，以便其他节点将能够正确映射该节点的地址
＃发布信息。
＃
＃如果未使用上述选项，则正常的Redis群集自动检测
＃将代替使用。
＃
＃请注意，重新映射后，总线端口可能不在的固定偏移量
＃客户端端口+ 10000，因此您可以根据需要指定任何端口和总线端口
＃如何重新映射它们。如果未设置总线端口，则固定偏移量为
＃10000将照常使用。
＃
＃示例：
＃
＃cluster-announce-ip 10.1.1.5
＃cluster-announce-port 6379
＃cluster-announce-bus-port 6380
############################### SLOW LOG ############### ####################

＃Redis Slow Log是用于记录超过指定数量的查询的系统
＃ 执行时间处理时间。执行时间不包括I / O操作
＃喜欢与客户交谈，发送回复等，
＃但仅是实际执行命令所需的时间（这是唯一的时间
＃执行命令的阶段，其中线程被阻塞并且无法服务
同时＃个其他请求）。
＃
＃您可以使用以下两个参数配置慢速日志：一个告诉Redis
＃为了使执行时间超出多少时间（以微秒为单位）
＃命令获取日志，另一个参数是长度
＃慢日志。记录新命令时，最旧的命令将从
＃已记录命令的队列。

＃以下时间以微秒表示，因此1000000等价
＃一秒钟。请注意，负数将禁用慢速日志记录，而
＃零值将强制记录每个命令。
slowlog日志慢于10000

＃此长度没有限制。请注意，它将消耗内存。
＃您可以使用SLOWLOG RESET回收慢速日志使用的内存。
slowlog-max-len 128

############################## LATENCY MONITOR ################# ##############

＃Redis延迟监视子系统对不同的操作进行采样
＃在运行时收集与可能的来源有关的数据
＃Redis实例的延迟。
＃
＃通过LATENCY命令，该信息对用户可用
＃打印图表并获取报告。
＃
＃系统仅记录在等于或等于时间的时间内执行的操作
＃大于通过指定的毫秒数
＃delay-monitor-threshold配置指令。设置其值时
＃设置为零，等待时间监视器关闭。
＃
＃默认情况下，延迟监视是禁用的，因为它几乎不需要
＃如果您没有延迟问题，并且收集数据可以提高性能
＃冲击虽然很小，但可以在大负载下测量。潜伏
使用以下命令可以在运行时轻松启用＃监视
＃“如果需要，请配置配置延迟监视器阈值<毫秒”。
latency-monitor-threshold 0
########################### EVENT NOTIFICATION #################### ###########

＃Redis可以将关键空间中发生的事件通知给发布/订阅客户端。
＃此功能记录在http://redis.io/topics/notifications
＃
＃例如，如果启用了键空间事件通知，并且客户端
＃对存储在数据库0中的键“ foo”执行DEL操作，两个
＃条消息将通过发布/订阅发布：
＃
# PUBLISH __keyspace@0__:foo del
# PUBLISH __keyevent@0__:del foo
＃
＃可以在一个集合中选择Redis将通知的事件
类数。每个类都由一个字符标识：
＃
＃K个键空间事件，以__keyspace @ <db> __前缀发布。
＃E Keyevent事件，以__keyevent @ <db> __前缀发布。
＃g通用命令（非类型专用），例如DEL，EXPIRE，RENAME，...
＃$字符串命令
＃l列出命令
＃s设置命令
＃h哈希命令
＃z排序集命令
＃x过期事件（每次密钥过期时生成的事件）
＃e驱逐事件（驱逐密钥以获取最大内存时生成的事件）
＃t流命令
＃m键丢失事件（注意：它不包含在“ A”类中）
＃g $ lshzxet的别名，因此“ AKE”字符串表示所有事件
＃（除了按键遗失事件外，由于它们
＃独特的性质）。
＃
＃“ notify-keyspace-events”将由组成的字符串作为参数
零个或多个字符的数量。空字符串表示通知
＃被禁用。
＃
＃示例：从列表的角度启用列表和一般事件
＃事件名称，使用：
＃
＃notify-keyspace-events Elg
＃
＃示例2：获取订阅频道的过期密钥流
＃名称__keyevent @ 0__：过期使用：
＃
＃notify-keyspace-events Ex
＃
＃默认情况下，所有通知都被禁用，因为大多数用户不需要
＃此功能，该功能会有一些开销。请注意，如果您不
＃指定K或E中的至少一个，不会传送任何事件。
notify-keyspace-events ""

############################## GOPHER SERVER ################# ################

＃Redis包含Gopher协议的实现，如
＃RFC 1436（https://www.ietf.org/rfc/rfc1436.txt）。
＃
＃Gopher协议在90年代后期非常流行。这是一种替代
＃到网络上，服务器和客户端的实现是如此简单
＃Redis服务器只有100行代码才能实现此功能
＃支持。
＃
＃您现在如何使用Gopher？好吧，地鼠从来没有*真的*死过，并且
＃最近为了让Gopher具有更高层次的内容而进行了一些移动
＃由纯文本文档组成，将要复活。有些人想要更简单
＃互联网，其他人认为主流互联网变得太多了
＃控制，为其他人创建替代空间很酷
＃想要一点新鲜空气。
＃
＃无论如何，在Redis诞生10周年之际，我们给了它Gopher协议
＃作为礼物。
＃
＃  - - 这个怎么运作？ ---
＃
＃Redis Gopher支持使用Redis的内联协议，特别是
＃两种仍然非法的内联请求：空请求
＃或任何以“ /”开头的请求（没有Redis命令开头
＃加上这样的斜线）。正常的RESP2 / RESP3请求完全超出了
＃Gopher协议实现的路径，也照常使用。
＃
＃如果启用Gopher后打开与Redis的连接并发送
＃一个类似“ / foo”的字符串，如果有一个名为“ / foo”的密钥，则通过
＃Gopher协议。
＃
＃为了创建一个真正的Gopher“漏洞”（Gopher中Gopher网站的名称，
＃说话），您可能需要以下脚本：
＃
＃https://github.com/antirez/gopher2redis
＃
＃  - - 安全警告  - -
＃
＃如果您打算将Redis放置在互联网上的公共地址中
＃到服务器Gopher页面上确保为实例设置密码。
＃设置密码后：
＃
＃1. Gopher服务器（启用时，默认情况下未启用）仍然可以使用
＃通过Gopher的内容。
＃2.但是，在客户端将无法调用其他命令之前
＃验证。
＃
＃因此，请使用'requirepass'选项来保护您的实例。
＃
＃请注意，“ io-threads-do-reads”当前不支持Gopher
＃已启用。
＃
＃要启用Gopher支持，请取消注释以下行并设置选项
＃从no（默认）到yes。
＃
# gopher-enabled no
############################## ADVANCED CONFIG ################# ##############

＃当散列具有
＃条目数量少，最大条目不超过给定
＃门槛。可以使用以下指令配置这些阈值。
hash-max-ziplist-entries 512
hash-max-ziplist-value 64

＃列表也以特殊方式编码，以节省大量空间。
＃可以指定每个内部列表节点允许的条目数
＃作为固定的最大大小或最大元素数。
＃对于固定的最大大小，请使用-5到-1，表示：
＃-5：最大大小：64 Kb <-不建议用于正常工作负载
＃-4：最大大小：32 Kb <-不推荐
＃-3：最大大小：16 Kb <-可能不建议
＃-2：最大大小：8 Kb <-好
＃-1：最大大小：4 Kb <-好
＃正数表示最多存储_exactly_个元素
＃每个列表节点。
＃效果最好的选项通常是-2（8 Kb大小）或-1（4 Kb大小），
＃但如果您的用例是唯一的，请根据需要调整设置。
list-max-ziplist-size -2

＃列表也可能被压缩。
＃压缩深度是从*每个*侧面开始的快速列表ziplist节点的数量
＃要从压缩中“排除”的列表。列表的首尾
＃始终未压缩以进行快速推入/弹出操作。设置为：
＃0：禁用所有列表压缩
＃1：深度1表示“直到列表中的1个节点之后才开始压缩，
＃从头到尾”
＃因此：[head]-> node-> node-> ...-> node-> [tail]
＃[head]，[tail]将始终未压缩；内部节点将压缩。
＃2：[head]-> [next]-> node-> node-> ...-> node-> [prev]-> [tail]
这里的＃2表示：不要压缩head或head-> next或tail-> prev或tail，
＃但压缩它们之间的所有节点。
＃3：[head]-> [next]-> [next]-> node-> node-> ...-> node-> [prev]-> [prev]-> [tail]
＃等
list-compress-depth 0

＃集合在一种情况下具有特殊的编码：组成集合时
恰好是基数10范围内的整数的字符串的数量
64位带符号整数的数量。
＃以下配置设置设置了大小限制
＃设置为使用此特殊的内存保存编码。
set-max-intset-entries 512

＃与哈希和列表类似，排序后的集合也专门编码为
＃为了节省很多空间。仅当长度和
排序集中的＃个元素低于以下限制：
zset-max-ziplist-entries 128
zset-max-ziplist-value 64

＃HyperLogLog稀疏表示字节数限制。该限制包括
＃16个字节的标头。当使用稀疏表示的HyperLogLog交叉时
＃此限制，它将转换为密集表示形式。
＃
＃大于16000的值完全没有用，因为此时
＃密集表示可提高内存效率。
＃
＃为了获得以下好处，建议值是〜3000
＃节省空间的编码而不会减慢PFADD，
＃是稀疏编码的O（N）。该值可以提高到
＃〜10000，当CPU不是问题，而是空间，并且数据集为
＃由许多基数在0-15000范围内的HyperLogLog组成。
hll-sparse-max-bytes 3000

＃流宏节点的最大大小/项目。流数据结构是一个基数
＃大节点树，内部编码多个项目。使用此配置
＃可以配置单个节点的字节数，并且
＃在以下情况下切换到新节点之前可能包含的最大项目数：
＃附加新的流条目。如果以下任何设置被设置为
＃零，限制被忽略，因此例如可以设置一个
＃通过将max-bytes设置为0并将max-entries设置为所需的最大整数限制
＃值。
stream-node-max-bytes 4096
stream-node-max-entries 100

＃主动重新哈希处理每100毫秒CPU时间使用1毫秒
＃为了帮助重新哈希主Redis哈希表（一个映射顶层）
＃个值键）。 Redis使用的哈希表实现（请参阅dict.c）
＃执行一次懒散的重新哈希处理：您在哈希表中运行的操作更多
＃正在重新哈希化，则执行更多的重新哈希化“步骤”，因此，如果
＃服务器处于空闲状态，重新哈希处理从未完成，并且使用了更多内存
＃通过哈希表。
＃
＃默认值是每秒使用此毫秒10次，以便
＃主动重新哈希主字典，并在可能的情况下释放内存。
＃
＃如果不确定：
＃如果您有严格的延迟要求，请使用“ activerehashing no”
＃在您的环境中，Redis可能会不时答复，这不是一件好事
＃查询2毫秒的延迟。
＃
＃如果您没有如此严格的要求，请使用“ activerehashing yes”
＃希望在可能的情况下尽快释放内存。
activerehashing yes

＃客户端输出缓冲区限制可用于强制断开客户端连接
＃由于某种原因没有足够快地从服务器读取数据（a
＃常见原因是发布/订阅客户端无法配置汇总消息的速度与
＃发布者可以制作它们）。
＃
＃可以为三种不同类别的客户端设置不同的限制：
＃
＃普通->普通客户端，包括MONITOR客户端
＃副本->副本客户端
＃pubsub->客户端订阅了至少一个pubsub频道或模式
＃
＃每个client-output-buffer-limit指令的语法如下：
＃
＃client-output-buffer-limit <class> <hard limit> <soft limit> <soft seconds>
＃
＃一旦达到硬限制，或者如果
＃达到软限制，并保持达到指定数量
＃秒（连续）。
＃例如，如果硬限制为32 MB，软限制为
＃16兆字节/ 10秒，客户端将立即断开连接
＃如果输出缓冲区的大小达到32兆字节，但也会
＃如果客户端达到16兆字节并持续克服，则断开连接
＃10秒的限制。
＃
＃默认情况下，普通客户端不受限制，因为它们不接收数据
＃不询问（以推送方式），而是在请求之后，因此仅
＃异步客户端可能会创建一个场景，在该场景中，数据请求速度更快
＃比它能读的多。
＃
＃相反，对于pubsub和副本客户端没有默认限制，因为
＃个订阅者和副本以推送方式接收数据。
＃
＃可以通过将硬限制或软限制设置为零来禁用它们。
client-output-buffer-limit normal 0 0 0
client-output-buffer-limit replica 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60

＃客户端查询缓冲区累积新命令。它们仅限于固定
默认情况下为＃数量，以避免协议失步（对于
＃实例（由于客户端中的错误）会导致未绑定的内存使用情况
＃查询缓冲区。但是，如果您有特殊要求，可以在此处进行配置
＃需求，例如我们巨大的multi / exec请求等等。
＃
＃client-query-buffer-limit 1gb

＃在Redis协议中，批量请求即表示单个请求的元素
＃个字符串，通常限制为512 mb。但是，您可以更改此限制
＃在这里，但必须大于等于1mb
＃
＃proto-max-bulk-len 512mb

＃Redis调用一个内部函数来执行许多后台任务，例如
＃在超时中关闭客户端连接，清除已过期的密钥
＃从未提出要求，依此类推。
＃
＃并非所有任务都以相同的频率执行，但是Redis会检查
＃根据指定的“ hz”值执行的任务。
＃
＃默认情况下，“ hz”设置为10。
＃Redis处于空闲状态，但同时会使Redis在
＃有许多键同时到期，并且可能超时
＃更精确地处理。
＃
＃范围介于1到500之间，但是通常不会超过100
＃ 一个好主意。大多数用户应使用默认值10并将其提高到
＃100仅在要求极低延迟的环境中使用。
hz 10
＃通常，将HZ值与
＃连接的客户端数。这很有用，例如
＃避免为每个后台任务调用处理过多的客户端
＃为了避免延迟尖峰。
＃
＃由于默认的默认HZ值保守地设置为10，因此Redis
＃提供并默认启用使用自适应HZ值的功能
＃当有许多连接的客户端时，它将临时升高。
＃
＃启用动态HZ时，将使用实际配置的HZ
＃作为基准，但实际上已配置的HZ值的倍数
＃在连接更多客户端后根据需要使用。这样闲置
＃实例将使用很少的CPU时间，而繁忙的实例将
＃更灵敏。
dynamic-hz yes

＃当孩子重写AOF文件时，如果启用以下选项
＃每生成32 MB的数据，文件就会进行同步处理。这很有用
＃为了将文件更多地提交到磁盘并避免
＃大的延迟峰值。
aof-rewrite-incremental-fsync yes

＃redis保存RDB文件时，如果启用以下选项
＃每生成32 MB的数据，文件就会进行同步处理。这很有用
＃为了将文件更多地提交到磁盘并避免
＃大的延迟峰值。
rdb-save-incremental-fsync yes

＃可以调整Redis LFU逐出（请参阅maxmemory设置）。但是，这是一个很好的
＃从默认设置开始的想法，只有在调查后才能更改它们
＃如何提高性能以及LFU的键随时间变化的方式，其中
＃可以通过OBJECT FREQ命令检查。
＃
＃Redis LFU实现中有两个可调参数：
＃计数器对数因子和计数器衰减时间。重要的是要
＃在更改它们之前了解两个参数的含义。
＃
＃LFU计数器每个密钥只有8位，最大值为255，因此Redis
＃使用具有对数行为的概率增量。赋予价值
旧计数器的编号，当访问一个键时，该计数器递增
＃ 这条路：
＃
＃1.提取介于0和1之间的随机数R。
＃2。将概率P计算为1 /（old_value * lfu_log_factor + 1）。
＃3.仅当R <P时，计数器才会递增。
＃
＃默认的lfu-log-factor是10。这是一个频率表
＃计数器随着访问次数的不同而变化，且访问次数不同
＃对数因子：
# +--------+------------+------------+------------+------------+------------+
# | factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |
# +--------+------------+------------+------------+------------+------------+
# | 0      | 104        | 255        | 255        | 255        | 255        |
# +--------+------------+------------+------------+------------+------------+
# | 1      | 18         | 49         | 255        | 255        | 255        |
# +--------+------------+------------+------------+------------+------------+
# | 10     | 10         | 18         | 142        | 255        | 255        |
# +--------+------------+------------+------------+------------+------------+
# | 100    | 8          | 11         | 49         | 143        | 255        |
# +--------+------------+------------+------------+------------+------------+
＃注意：上表是通过运行以下命令获得的：
＃
#   redis-benchmark -n 1000000 incr foo
#   redis-cli object freq foo
＃
＃注意2：计数器的初始值为5，以便为新对象提供机会
＃累积点击数。
＃
＃计数器衰减时间是按顺序必须经过的时间（以分钟为单位）
＃将密钥计数器除以2（如果有值则减1
＃小于<= 10）。
＃
＃lfu-decay-time的默认值为1。特殊值为0表示：
＃每次碰巧扫描计数器时都会使其衰减。
＃
＃lfu-log-factor 10
＃lfu-decay-time 1
########################## Active DEFRAGMENTATION ####################### ##
＃
＃什么是主动碎片整理？
＃-------------------------------
＃
＃主动（在线）碎片整理允许Redis服务器压缩
＃在内存中的小量分配和释放之间留有空格，
＃因此可以回收内存。
＃
＃碎片是每个分配器都会发生的自然过程（但
＃幸运的是，Jemalloc和某些工作负载更少。通常是一台服务器
＃重新启动是必要的，以减少碎片或至少冲洗
＃删除所有数据并再次创建。但是由于这个功能
＃由Oran Agra针对Redis 4.0实施，此过程可以在运行时发生
＃在服务器运行时以“热”方式。
＃
＃基本上在碎片超过一定水平时（请参阅
＃下面的配置选项），Redis将开始创建新的副本
通过利用某些特定的Jemalloc在连续内存区域中的＃个值
＃功能（以了解分配是否引起碎片
＃并将其分配到更好的位置），同时，将释放
＃数据的旧副本。对所有键逐步重复此过程
＃将导致碎片恢复到正常值。
＃
＃重要事项：
＃
＃1.此功能默认情况下处于禁用状态，仅在编译Redis时有效
＃使用我们随附Redis源代码的Jemalloc副本。
＃这是Linux构建的默认设置。
＃
＃2.如果没有碎片，则永远不需要启用此功能
＃个问题。
＃
＃3。一旦遇到碎片，您可以在以下情况启用此功能：
＃需要使用命令“ CONFIG SET activedefrag yes”。
＃
＃配置参数能够微调
＃碎片整理过程。如果您不确定它们是什么意思
＃保持默认值不变的好主意。

＃启用主动碎片整理
＃activedefrag no

＃启动主动碎片整理的最小碎片浪费量
＃active-defrag-ignore-bytes 100mb

＃启动活动碎片整理的最小碎片百分比
＃active-defrag-threshold-lower 10

＃我们最大程度地努力下的最大碎片百分比
＃active-defrag-threshold-upper 100

＃在CPU百分比上进行最小整理的工作量，在较低时使用
达到＃个阈值
＃active-defrag-cycle-min 1

＃最大程度地整理CPU百分比的碎片
达到＃个阈值
＃active-defrag-cycle-max 25

＃将要处理的set / hash / zset / list字段的最大数量
＃主字典扫描
＃active-defrag-max-scan-fields 1000

＃默认情况下，将启用用于清除的Jemalloc后台线程
jemalloc-bg-thread yes

＃可以将Redis的不同线程和进程固定到特定的
＃系统中的CPU，以便最大化服务器的性能。
＃这对于将不同的Redis线程固定在不同的位置都是有用的
＃CPU，也为了确保多个Redis实例正在运行
同一主机中的＃将固定到不同的CPU。
＃
＃通常，您可以使用“ taskset”命令执行此操作，但是也可以
＃在Linux和FreeBSD中都可以通过Redis直接配置。
＃
＃您可以固定服务器/ IO线程，生物线程，aof重写子进程以及
＃bgsave子进程。指定cpu列表的语法与
＃tasket命令：
＃
＃将Redis服务器/ IO线程设置为CPU关联0、2、4、6：
＃server_cpulist 0-7：2
＃
＃将生物线程设置为cpu亲和力1,3：
＃bio_cpulist 1,3
＃
＃将aof rewrite子进程设置为cpu亲和力8,9,10,11：
＃aof_rewrite_cpulist 8-11
＃
＃将bgsave子进程设置为cpu亲和力1,10,11
＃bgsave_cpulist 1,10-11
```

